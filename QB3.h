#pragma once
#include <vector>
#include <cinttypes>
#include <limits>
//#include <functional>
#include <cassert>
#include <utility>
#if defined(_WIN32)
#include <intrin.h>
#endif

// Define this to minimize the size of the code, loosing some speed for large data types
// #define QB3_OPTIMIZE_ONLY_BYTE

#if defined(__GNUC__) && defined(__x86_64__)
// Comment out if binary is to run on processors without sse4
#pragma GCC target("sse4")
#endif

namespace QB3 {
    // Masks, from 0 to 64 rung
#define M(v) (~0ull >> (64 - (v)))
// A row of 8 masks, starting with mask(n)
#define R(n) M(n), M(n + 1), M(n + 2), M(n + 3), M(n + 4), M(n + 5), M(n + 6), M(n + 7)
    const uint64_t mask[] = { 0, R(1), R(9), R(17), R(25), R(33), R(41), R(49), R(57) };
#undef R

#if defined(_WIN32_)
// rank of top set bit, result is undefined for val == 0
static size_t topbit(uint64_t val) {
    return 63 - __lzcnt64(val);
}

static size_t setbits(uint64_t val) {
    return __popcnt64(val);
}

static size_t setbits16(uint64_t val) {
    return __popcnt64(val);
}

#elif defined(__GNUC__)
static size_t topbit(uint64_t val) {
    return 63 - __builtin_clzll(val);
}

static size_t setbits(uint64_t val) {
    return __builtin_popcountll(val);
}

static size_t setbits16(uint64_t val) {
    return setbits(val);
}

#else // no builtins, portable C
static size_t topbit(uint64_t val) {
    unsigned r = 0;
    while (val >>= 1)
        r++;
    return r;
}

// My own portable byte bitcount
static inline int nbits(unsigned char v) {
    return ((((v - ((v >> 1) & 0x55u)) * 0x1010101u) & 0x30c00c03u) * 0x10040041u) >> 0x1cu;
}

// This should get vectorized
static size_t setbits(uint64_t val) {
    return nbits(0xff & val) + nbits(0xff & (val >> 8)) + nbits(0xff & (val >> 16)) + nbits(0xff & (val >> 24))
        + nbits(0xff & (val >> 32)) + nbits(0xff & (val >> 40)) + nbits(0xff & (val >> 48)) + nbits(0xff & (val >> 56));
}

static size_t setbits16(uint64_t val) {
    return nbits(0xff & val) + nbits(0xff & (val >> 8));
}
#endif

// Looks for 1*0* in the rung bits of the input values, returns the position of last 1
// Assumes at least one of the bits is set
template<typename T>
static size_t stepleft(const T * const v, size_t rung) {
    const int B2 = 16;
    // We are looking for 1*0* pattern on the B2 bits
    uint64_t acc = ~0ull;
    // collect inverted rung bits, we are now looking for 0*1*
    for (int i = 0; i < B2; i++)
        acc = (acc << 1) | (1 & (v[i] >> rung));
    // Flip bits so the top ones are 0 and bottom ones are 1
    acc = ~acc;

    // Can call topbit since acc != 0
    if (topbit(acc) != setbits16(acc) - 1)
        return B2;
    return B2 - 1 - setbits16(acc);
}

// Undo the stepdown shift
// Looks for 1*0* in the rung bits of the input values, returns the position of first 0
// If the group was stepdown left shifted, the last rung bit has to be 0
template<typename T>
static size_t stepright(const T* const v, size_t rung) {
    const int B2 = 16;
    // We are looking for 1*0* pattern on the B2 bits
    uint64_t acc = ~0ull;
    // collect inverted rung bits, we are now looking for 0*1*
    for (int i = 0; i < B2; i++)
        acc = (acc << 1) | (1 & (v[i] >> rung));
    // Flip bits so the top ones are 0 and bottom ones are 1
    acc = ~acc;

    // Can call topbit since acc != 0
    if (topbit(acc) != setbits16(acc) - 1)
        return B2;
    return B2 - setbits16(acc);
}

// Greater common denominator
template<typename T>
T gcd(const std::vector<T>& vals) {
    if (vals.empty())
        return 0;
    auto v(vals); // Work on a copy
    auto vb(v.begin()), ve(v.end());
    for (;;) {
        sort(vb, ve);
        while (!*vb) // Skip the zeros
            if (++vb == ve)
                return 0;
        auto m(*vb); // smallest value
        if (vb + 1 == ve)
            return m; // Done
        for (auto vi(vb + 1); vi < ve; vi++)
            *vi %= m;
    }
    // Not reached
    return 0;
}

// Convert from mag-sign to absolute
template<typename T>
inline T revs(T val) {
    return (val >> 1) + (val & 1);
}

// return greatest common factor
// T is always unsigned
template<typename T>
T gcode(const std::vector<T>& vals) {

    // heap of absolute values
    std::vector<T> v;
    v.reserve(vals.size());
    for (auto val : vals) {
        // ignore the zeros
        if (val == 0) continue;
        // if a value is 1 or -1, the only common factor will be 1
        if (val < 3) return 1;
        v.push_back(revs(val));
        push_heap(v.begin(), v.end(), std::greater<T>());
    }

    if (v.empty() || v.front() < 3)
        return 1;

    do {
        pop_heap(v.begin(), v.end(), std::greater<T>());
        const T m(v.back()); // never less than 2
        v.pop_back();
        for (auto& t : v) t %= m;
        v.push_back(m); // v is never empty
        make_heap(v.begin(), v.end(), std::greater<T>());
        while (v.size() && v.front() == 0) {
            pop_heap(v.begin(), v.end(), std::greater<T>());
            v.pop_back();
        }
        if (1 == v.front())
            return 1;
    } while (v.size() > 1);
    return v.front();
}

//
// Delta and sign reorder
// All these templates work only for T unsigned, integer, 2s complement types
// Even though T is unsigned, it is considered signed, that's the whole point!
//


// Encode integers as absolute magnitude and sign, so the bit 0 is the sign.
// This encoding has the top rung always zero, regardless of sign
// To keep the range exactly the same as two's complement, the magnitude of negative values is biased down by one (no negative zero)


// Change to mag-sign without conditionals, as fast as C can make it
template<typename T>
static T mags(T v) {
    return (std::numeric_limits<T>::max() * (v >> (8 * sizeof(T) - 1))) ^ (v << 1);
}

// Undo mag-sign without conditionals, as fast as C can make it
template<typename T>
static T smag(T v) {
    return (std::numeric_limits<T>::max() * (v & 1)) ^ (v >> 1);
}

// Convert a sequence to mag-sign delta
template<typename T, size_t B2 = 16>
static T dsign(T *v, T pred) {
    static_assert(std::is_integral<T>::value && std::is_unsigned<T>::value,
        "Only works for unsigned integral types");
    for (int i = 0; i < B2; i++) {
        pred += v[i] -= pred; // or std::swap(v[i], pred); v[i] = pred - v[i] 
        v[i] = mags(v[i]);
    }
    return pred;
}

// Reverse mag-sign and delta
template<typename T, size_t B2 = 16>
static T undsign(T *v, T pred) {
    for (int i = 0; i < B2; i++)
        v[i] = pred += smag(v[i]);
    return pred;
}

// Block size should be 8, for noisy images 4 is better
// 2 generates too much overhead
// 16 might work for slow varying inputs
// which would need the lookup tables extended

// Traversal order tables
#if defined(LINEAR)
static const int xlut[16] = { 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3 };
static const int ylut[16] = { 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3 };
#elif defined(DIAG)
static const int xlut[16] = { 0, 1, 0, 2, 1, 0, 3, 2, 1, 0, 3, 2, 1, 3, 2, 3 };
static const int ylut[16] = { 0, 0, 1, 0, 1, 2, 0, 1, 2, 3, 1, 2, 3, 2, 3, 3 };
#else
// Better in most cases
static const int xlut[16] = { 0, 1, 0, 1, 2, 3, 2, 3, 0, 1, 0, 1, 2, 3, 2, 3 };
static const int ylut[16] = { 0, 0, 1, 1, 0, 0, 1, 1, 2, 2, 3, 3, 2, 2, 3, 3 };
#endif

// QB3 encoding tables for rungs 2 to 11, for speedup. Rung 0 and 1 are special
// Storage is under 8K by using short int, or under 1K when only byte data is optimized
// See tables.py for how they are generated
#define TBLMASK 0xfffull
static const uint16_t crg1[] = {0x1000, 0x2003, 0x3001, 0x3005};
static const uint16_t crg2[] = {0x2002, 0x2003, 0x3001, 0x3005, 0x4000, 0x4004, 0x4008, 0x400c};
static const uint16_t crg3[] = {0x3004, 0x3005, 0x3006, 0x3007, 0x4002, 0x400a, 0x4003, 0x400b, 0x5000, 0x5008, 0x5010, 0x5018,
0x5001, 0x5009, 0x5011, 0x5019};
static const uint16_t crg4[] = {0x4008, 0x4009, 0x400a, 0x400b, 0x400c, 0x400d, 0x400e, 0x400f, 0x5004, 0x5014, 0x5005, 0x5015,
0x5006, 0x5016, 0x5007, 0x5017, 0x6000, 0x6010, 0x6020, 0x6030, 0x6001, 0x6011, 0x6021, 0x6031, 0x6002, 0x6012, 0x6022, 0x6032,
0x6003, 0x6013, 0x6023, 0x6033};
static const uint16_t crg5[] = {0x5010, 0x5011, 0x5012, 0x5013, 0x5014, 0x5015, 0x5016, 0x5017, 0x5018, 0x5019, 0x501a, 0x501b,
0x501c, 0x501d, 0x501e, 0x501f, 0x6008, 0x6028, 0x6009, 0x6029, 0x600a, 0x602a, 0x600b, 0x602b, 0x600c, 0x602c, 0x600d, 0x602d,
0x600e, 0x602e, 0x600f, 0x602f, 0x7000, 0x7020, 0x7040, 0x7060, 0x7001, 0x7021, 0x7041, 0x7061, 0x7002, 0x7022, 0x7042, 0x7062,
0x7003, 0x7023, 0x7043, 0x7063, 0x7004, 0x7024, 0x7044, 0x7064, 0x7005, 0x7025, 0x7045, 0x7065, 0x7006, 0x7026, 0x7046, 0x7066,
0x7007, 0x7027, 0x7047, 0x7067};
static const uint16_t crg6[] = {0x6020, 0x6021, 0x6022, 0x6023, 0x6024, 0x6025, 0x6026, 0x6027, 0x6028, 0x6029, 0x602a, 0x602b,
0x602c, 0x602d, 0x602e, 0x602f, 0x6030, 0x6031, 0x6032, 0x6033, 0x6034, 0x6035, 0x6036, 0x6037, 0x6038, 0x6039, 0x603a, 0x603b,
0x603c, 0x603d, 0x603e, 0x603f, 0x7010, 0x7050, 0x7011, 0x7051, 0x7012, 0x7052, 0x7013, 0x7053, 0x7014, 0x7054, 0x7015, 0x7055,
0x7016, 0x7056, 0x7017, 0x7057, 0x7018, 0x7058, 0x7019, 0x7059, 0x701a, 0x705a, 0x701b, 0x705b, 0x701c, 0x705c, 0x701d, 0x705d,
0x701e, 0x705e, 0x701f, 0x705f, 0x8000, 0x8040, 0x8080, 0x80c0, 0x8001, 0x8041, 0x8081, 0x80c1, 0x8002, 0x8042, 0x8082, 0x80c2,
0x8003, 0x8043, 0x8083, 0x80c3, 0x8004, 0x8044, 0x8084, 0x80c4, 0x8005, 0x8045, 0x8085, 0x80c5, 0x8006, 0x8046, 0x8086, 0x80c6,
0x8007, 0x8047, 0x8087, 0x80c7, 0x8008, 0x8048, 0x8088, 0x80c8, 0x8009, 0x8049, 0x8089, 0x80c9, 0x800a, 0x804a, 0x808a, 0x80ca,
0x800b, 0x804b, 0x808b, 0x80cb, 0x800c, 0x804c, 0x808c, 0x80cc, 0x800d, 0x804d, 0x808d, 0x80cd, 0x800e, 0x804e, 0x808e, 0x80ce,
0x800f, 0x804f, 0x808f, 0x80cf};
static const uint16_t crg7[] = {0x7040, 0x7041, 0x7042, 0x7043, 0x7044, 0x7045, 0x7046, 0x7047, 0x7048, 0x7049, 0x704a, 0x704b,
0x704c, 0x704d, 0x704e, 0x704f, 0x7050, 0x7051, 0x7052, 0x7053, 0x7054, 0x7055, 0x7056, 0x7057, 0x7058, 0x7059, 0x705a, 0x705b,
0x705c, 0x705d, 0x705e, 0x705f, 0x7060, 0x7061, 0x7062, 0x7063, 0x7064, 0x7065, 0x7066, 0x7067, 0x7068, 0x7069, 0x706a, 0x706b,
0x706c, 0x706d, 0x706e, 0x706f, 0x7070, 0x7071, 0x7072, 0x7073, 0x7074, 0x7075, 0x7076, 0x7077, 0x7078, 0x7079, 0x707a, 0x707b,
0x707c, 0x707d, 0x707e, 0x707f, 0x8020, 0x80a0, 0x8021, 0x80a1, 0x8022, 0x80a2, 0x8023, 0x80a3, 0x8024, 0x80a4, 0x8025, 0x80a5,
0x8026, 0x80a6, 0x8027, 0x80a7, 0x8028, 0x80a8, 0x8029, 0x80a9, 0x802a, 0x80aa, 0x802b, 0x80ab, 0x802c, 0x80ac, 0x802d, 0x80ad,
0x802e, 0x80ae, 0x802f, 0x80af, 0x8030, 0x80b0, 0x8031, 0x80b1, 0x8032, 0x80b2, 0x8033, 0x80b3, 0x8034, 0x80b4, 0x8035, 0x80b5,
0x8036, 0x80b6, 0x8037, 0x80b7, 0x8038, 0x80b8, 0x8039, 0x80b9, 0x803a, 0x80ba, 0x803b, 0x80bb, 0x803c, 0x80bc, 0x803d, 0x80bd,
0x803e, 0x80be, 0x803f, 0x80bf, 0x9000, 0x9080, 0x9100, 0x9180, 0x9001, 0x9081, 0x9101, 0x9181, 0x9002, 0x9082, 0x9102, 0x9182,
0x9003, 0x9083, 0x9103, 0x9183, 0x9004, 0x9084, 0x9104, 0x9184, 0x9005, 0x9085, 0x9105, 0x9185, 0x9006, 0x9086, 0x9106, 0x9186,
0x9007, 0x9087, 0x9107, 0x9187, 0x9008, 0x9088, 0x9108, 0x9188, 0x9009, 0x9089, 0x9109, 0x9189, 0x900a, 0x908a, 0x910a, 0x918a,
0x900b, 0x908b, 0x910b, 0x918b, 0x900c, 0x908c, 0x910c, 0x918c, 0x900d, 0x908d, 0x910d, 0x918d, 0x900e, 0x908e, 0x910e, 0x918e,
0x900f, 0x908f, 0x910f, 0x918f, 0x9010, 0x9090, 0x9110, 0x9190, 0x9011, 0x9091, 0x9111, 0x9191, 0x9012, 0x9092, 0x9112, 0x9192,
0x9013, 0x9093, 0x9113, 0x9193, 0x9014, 0x9094, 0x9114, 0x9194, 0x9015, 0x9095, 0x9115, 0x9195, 0x9016, 0x9096, 0x9116, 0x9196,
0x9017, 0x9097, 0x9117, 0x9197, 0x9018, 0x9098, 0x9118, 0x9198, 0x9019, 0x9099, 0x9119, 0x9199, 0x901a, 0x909a, 0x911a, 0x919a,
0x901b, 0x909b, 0x911b, 0x919b, 0x901c, 0x909c, 0x911c, 0x919c, 0x901d, 0x909d, 0x911d, 0x919d, 0x901e, 0x909e, 0x911e, 0x919e,
0x901f, 0x909f, 0x911f, 0x919f};

#if defined(QB3_OPTIMIZE_ONLY_BYTE)
static const uint16_t *CRG[] = {nullptr, crg1, crg2, crg3, crg4, crg5, crg6, crg7};
#else
// Define encoding tables for rungs 8, 9 and 10. They make no difference when encoding byte data
static const uint16_t crg8[] = { 0x8080, 0x8081, 0x8082, 0x8083, 0x8084, 0x8085, 0x8086, 0x8087, 0x8088, 0x8089, 0x808a, 0x808b,
0x808c, 0x808d, 0x808e, 0x808f, 0x8090, 0x8091, 0x8092, 0x8093, 0x8094, 0x8095, 0x8096, 0x8097, 0x8098, 0x8099, 0x809a, 0x809b,
0x809c, 0x809d, 0x809e, 0x809f, 0x80a0, 0x80a1, 0x80a2, 0x80a3, 0x80a4, 0x80a5, 0x80a6, 0x80a7, 0x80a8, 0x80a9, 0x80aa, 0x80ab,
0x80ac, 0x80ad, 0x80ae, 0x80af, 0x80b0, 0x80b1, 0x80b2, 0x80b3, 0x80b4, 0x80b5, 0x80b6, 0x80b7, 0x80b8, 0x80b9, 0x80ba, 0x80bb,
0x80bc, 0x80bd, 0x80be, 0x80bf, 0x80c0, 0x80c1, 0x80c2, 0x80c3, 0x80c4, 0x80c5, 0x80c6, 0x80c7, 0x80c8, 0x80c9, 0x80ca, 0x80cb,
0x80cc, 0x80cd, 0x80ce, 0x80cf, 0x80d0, 0x80d1, 0x80d2, 0x80d3, 0x80d4, 0x80d5, 0x80d6, 0x80d7, 0x80d8, 0x80d9, 0x80da, 0x80db,
0x80dc, 0x80dd, 0x80de, 0x80df, 0x80e0, 0x80e1, 0x80e2, 0x80e3, 0x80e4, 0x80e5, 0x80e6, 0x80e7, 0x80e8, 0x80e9, 0x80ea, 0x80eb,
0x80ec, 0x80ed, 0x80ee, 0x80ef, 0x80f0, 0x80f1, 0x80f2, 0x80f3, 0x80f4, 0x80f5, 0x80f6, 0x80f7, 0x80f8, 0x80f9, 0x80fa, 0x80fb,
0x80fc, 0x80fd, 0x80fe, 0x80ff, 0x9040, 0x9140, 0x9041, 0x9141, 0x9042, 0x9142, 0x9043, 0x9143, 0x9044, 0x9144, 0x9045, 0x9145,
0x9046, 0x9146, 0x9047, 0x9147, 0x9048, 0x9148, 0x9049, 0x9149, 0x904a, 0x914a, 0x904b, 0x914b, 0x904c, 0x914c, 0x904d, 0x914d,
0x904e, 0x914e, 0x904f, 0x914f, 0x9050, 0x9150, 0x9051, 0x9151, 0x9052, 0x9152, 0x9053, 0x9153, 0x9054, 0x9154, 0x9055, 0x9155,
0x9056, 0x9156, 0x9057, 0x9157, 0x9058, 0x9158, 0x9059, 0x9159, 0x905a, 0x915a, 0x905b, 0x915b, 0x905c, 0x915c, 0x905d, 0x915d,
0x905e, 0x915e, 0x905f, 0x915f, 0x9060, 0x9160, 0x9061, 0x9161, 0x9062, 0x9162, 0x9063, 0x9163, 0x9064, 0x9164, 0x9065, 0x9165,
0x9066, 0x9166, 0x9067, 0x9167, 0x9068, 0x9168, 0x9069, 0x9169, 0x906a, 0x916a, 0x906b, 0x916b, 0x906c, 0x916c, 0x906d, 0x916d,
0x906e, 0x916e, 0x906f, 0x916f, 0x9070, 0x9170, 0x9071, 0x9171, 0x9072, 0x9172, 0x9073, 0x9173, 0x9074, 0x9174, 0x9075, 0x9175,
0x9076, 0x9176, 0x9077, 0x9177, 0x9078, 0x9178, 0x9079, 0x9179, 0x907a, 0x917a, 0x907b, 0x917b, 0x907c, 0x917c, 0x907d, 0x917d,
0x907e, 0x917e, 0x907f, 0x917f, 0xa000, 0xa100, 0xa200, 0xa300, 0xa001, 0xa101, 0xa201, 0xa301, 0xa002, 0xa102, 0xa202, 0xa302,
0xa003, 0xa103, 0xa203, 0xa303, 0xa004, 0xa104, 0xa204, 0xa304, 0xa005, 0xa105, 0xa205, 0xa305, 0xa006, 0xa106, 0xa206, 0xa306,
0xa007, 0xa107, 0xa207, 0xa307, 0xa008, 0xa108, 0xa208, 0xa308, 0xa009, 0xa109, 0xa209, 0xa309, 0xa00a, 0xa10a, 0xa20a, 0xa30a,
0xa00b, 0xa10b, 0xa20b, 0xa30b, 0xa00c, 0xa10c, 0xa20c, 0xa30c, 0xa00d, 0xa10d, 0xa20d, 0xa30d, 0xa00e, 0xa10e, 0xa20e, 0xa30e,
0xa00f, 0xa10f, 0xa20f, 0xa30f, 0xa010, 0xa110, 0xa210, 0xa310, 0xa011, 0xa111, 0xa211, 0xa311, 0xa012, 0xa112, 0xa212, 0xa312,
0xa013, 0xa113, 0xa213, 0xa313, 0xa014, 0xa114, 0xa214, 0xa314, 0xa015, 0xa115, 0xa215, 0xa315, 0xa016, 0xa116, 0xa216, 0xa316,
0xa017, 0xa117, 0xa217, 0xa317, 0xa018, 0xa118, 0xa218, 0xa318, 0xa019, 0xa119, 0xa219, 0xa319, 0xa01a, 0xa11a, 0xa21a, 0xa31a,
0xa01b, 0xa11b, 0xa21b, 0xa31b, 0xa01c, 0xa11c, 0xa21c, 0xa31c, 0xa01d, 0xa11d, 0xa21d, 0xa31d, 0xa01e, 0xa11e, 0xa21e, 0xa31e,
0xa01f, 0xa11f, 0xa21f, 0xa31f, 0xa020, 0xa120, 0xa220, 0xa320, 0xa021, 0xa121, 0xa221, 0xa321, 0xa022, 0xa122, 0xa222, 0xa322,
0xa023, 0xa123, 0xa223, 0xa323, 0xa024, 0xa124, 0xa224, 0xa324, 0xa025, 0xa125, 0xa225, 0xa325, 0xa026, 0xa126, 0xa226, 0xa326,
0xa027, 0xa127, 0xa227, 0xa327, 0xa028, 0xa128, 0xa228, 0xa328, 0xa029, 0xa129, 0xa229, 0xa329, 0xa02a, 0xa12a, 0xa22a, 0xa32a,
0xa02b, 0xa12b, 0xa22b, 0xa32b, 0xa02c, 0xa12c, 0xa22c, 0xa32c, 0xa02d, 0xa12d, 0xa22d, 0xa32d, 0xa02e, 0xa12e, 0xa22e, 0xa32e,
0xa02f, 0xa12f, 0xa22f, 0xa32f, 0xa030, 0xa130, 0xa230, 0xa330, 0xa031, 0xa131, 0xa231, 0xa331, 0xa032, 0xa132, 0xa232, 0xa332,
0xa033, 0xa133, 0xa233, 0xa333, 0xa034, 0xa134, 0xa234, 0xa334, 0xa035, 0xa135, 0xa235, 0xa335, 0xa036, 0xa136, 0xa236, 0xa336,
0xa037, 0xa137, 0xa237, 0xa337, 0xa038, 0xa138, 0xa238, 0xa338, 0xa039, 0xa139, 0xa239, 0xa339, 0xa03a, 0xa13a, 0xa23a, 0xa33a,
0xa03b, 0xa13b, 0xa23b, 0xa33b, 0xa03c, 0xa13c, 0xa23c, 0xa33c, 0xa03d, 0xa13d, 0xa23d, 0xa33d, 0xa03e, 0xa13e, 0xa23e, 0xa33e,
0xa03f, 0xa13f, 0xa23f, 0xa33f };
static const uint16_t crg9[] = { 0x9100, 0x9101, 0x9102, 0x9103, 0x9104, 0x9105, 0x9106, 0x9107, 0x9108, 0x9109, 0x910a, 0x910b,
0x910c, 0x910d, 0x910e, 0x910f, 0x9110, 0x9111, 0x9112, 0x9113, 0x9114, 0x9115, 0x9116, 0x9117, 0x9118, 0x9119, 0x911a, 0x911b,
0x911c, 0x911d, 0x911e, 0x911f, 0x9120, 0x9121, 0x9122, 0x9123, 0x9124, 0x9125, 0x9126, 0x9127, 0x9128, 0x9129, 0x912a, 0x912b,
0x912c, 0x912d, 0x912e, 0x912f, 0x9130, 0x9131, 0x9132, 0x9133, 0x9134, 0x9135, 0x9136, 0x9137, 0x9138, 0x9139, 0x913a, 0x913b,
0x913c, 0x913d, 0x913e, 0x913f, 0x9140, 0x9141, 0x9142, 0x9143, 0x9144, 0x9145, 0x9146, 0x9147, 0x9148, 0x9149, 0x914a, 0x914b,
0x914c, 0x914d, 0x914e, 0x914f, 0x9150, 0x9151, 0x9152, 0x9153, 0x9154, 0x9155, 0x9156, 0x9157, 0x9158, 0x9159, 0x915a, 0x915b,
0x915c, 0x915d, 0x915e, 0x915f, 0x9160, 0x9161, 0x9162, 0x9163, 0x9164, 0x9165, 0x9166, 0x9167, 0x9168, 0x9169, 0x916a, 0x916b,
0x916c, 0x916d, 0x916e, 0x916f, 0x9170, 0x9171, 0x9172, 0x9173, 0x9174, 0x9175, 0x9176, 0x9177, 0x9178, 0x9179, 0x917a, 0x917b,
0x917c, 0x917d, 0x917e, 0x917f, 0x9180, 0x9181, 0x9182, 0x9183, 0x9184, 0x9185, 0x9186, 0x9187, 0x9188, 0x9189, 0x918a, 0x918b,
0x918c, 0x918d, 0x918e, 0x918f, 0x9190, 0x9191, 0x9192, 0x9193, 0x9194, 0x9195, 0x9196, 0x9197, 0x9198, 0x9199, 0x919a, 0x919b,
0x919c, 0x919d, 0x919e, 0x919f, 0x91a0, 0x91a1, 0x91a2, 0x91a3, 0x91a4, 0x91a5, 0x91a6, 0x91a7, 0x91a8, 0x91a9, 0x91aa, 0x91ab,
0x91ac, 0x91ad, 0x91ae, 0x91af, 0x91b0, 0x91b1, 0x91b2, 0x91b3, 0x91b4, 0x91b5, 0x91b6, 0x91b7, 0x91b8, 0x91b9, 0x91ba, 0x91bb,
0x91bc, 0x91bd, 0x91be, 0x91bf, 0x91c0, 0x91c1, 0x91c2, 0x91c3, 0x91c4, 0x91c5, 0x91c6, 0x91c7, 0x91c8, 0x91c9, 0x91ca, 0x91cb,
0x91cc, 0x91cd, 0x91ce, 0x91cf, 0x91d0, 0x91d1, 0x91d2, 0x91d3, 0x91d4, 0x91d5, 0x91d6, 0x91d7, 0x91d8, 0x91d9, 0x91da, 0x91db,
0x91dc, 0x91dd, 0x91de, 0x91df, 0x91e0, 0x91e1, 0x91e2, 0x91e3, 0x91e4, 0x91e5, 0x91e6, 0x91e7, 0x91e8, 0x91e9, 0x91ea, 0x91eb,
0x91ec, 0x91ed, 0x91ee, 0x91ef, 0x91f0, 0x91f1, 0x91f2, 0x91f3, 0x91f4, 0x91f5, 0x91f6, 0x91f7, 0x91f8, 0x91f9, 0x91fa, 0x91fb,
0x91fc, 0x91fd, 0x91fe, 0x91ff, 0xa080, 0xa280, 0xa081, 0xa281, 0xa082, 0xa282, 0xa083, 0xa283, 0xa084, 0xa284, 0xa085, 0xa285,
0xa086, 0xa286, 0xa087, 0xa287, 0xa088, 0xa288, 0xa089, 0xa289, 0xa08a, 0xa28a, 0xa08b, 0xa28b, 0xa08c, 0xa28c, 0xa08d, 0xa28d,
0xa08e, 0xa28e, 0xa08f, 0xa28f, 0xa090, 0xa290, 0xa091, 0xa291, 0xa092, 0xa292, 0xa093, 0xa293, 0xa094, 0xa294, 0xa095, 0xa295,
0xa096, 0xa296, 0xa097, 0xa297, 0xa098, 0xa298, 0xa099, 0xa299, 0xa09a, 0xa29a, 0xa09b, 0xa29b, 0xa09c, 0xa29c, 0xa09d, 0xa29d,
0xa09e, 0xa29e, 0xa09f, 0xa29f, 0xa0a0, 0xa2a0, 0xa0a1, 0xa2a1, 0xa0a2, 0xa2a2, 0xa0a3, 0xa2a3, 0xa0a4, 0xa2a4, 0xa0a5, 0xa2a5,
0xa0a6, 0xa2a6, 0xa0a7, 0xa2a7, 0xa0a8, 0xa2a8, 0xa0a9, 0xa2a9, 0xa0aa, 0xa2aa, 0xa0ab, 0xa2ab, 0xa0ac, 0xa2ac, 0xa0ad, 0xa2ad,
0xa0ae, 0xa2ae, 0xa0af, 0xa2af, 0xa0b0, 0xa2b0, 0xa0b1, 0xa2b1, 0xa0b2, 0xa2b2, 0xa0b3, 0xa2b3, 0xa0b4, 0xa2b4, 0xa0b5, 0xa2b5,
0xa0b6, 0xa2b6, 0xa0b7, 0xa2b7, 0xa0b8, 0xa2b8, 0xa0b9, 0xa2b9, 0xa0ba, 0xa2ba, 0xa0bb, 0xa2bb, 0xa0bc, 0xa2bc, 0xa0bd, 0xa2bd,
0xa0be, 0xa2be, 0xa0bf, 0xa2bf, 0xa0c0, 0xa2c0, 0xa0c1, 0xa2c1, 0xa0c2, 0xa2c2, 0xa0c3, 0xa2c3, 0xa0c4, 0xa2c4, 0xa0c5, 0xa2c5,
0xa0c6, 0xa2c6, 0xa0c7, 0xa2c7, 0xa0c8, 0xa2c8, 0xa0c9, 0xa2c9, 0xa0ca, 0xa2ca, 0xa0cb, 0xa2cb, 0xa0cc, 0xa2cc, 0xa0cd, 0xa2cd,
0xa0ce, 0xa2ce, 0xa0cf, 0xa2cf, 0xa0d0, 0xa2d0, 0xa0d1, 0xa2d1, 0xa0d2, 0xa2d2, 0xa0d3, 0xa2d3, 0xa0d4, 0xa2d4, 0xa0d5, 0xa2d5,
0xa0d6, 0xa2d6, 0xa0d7, 0xa2d7, 0xa0d8, 0xa2d8, 0xa0d9, 0xa2d9, 0xa0da, 0xa2da, 0xa0db, 0xa2db, 0xa0dc, 0xa2dc, 0xa0dd, 0xa2dd,
0xa0de, 0xa2de, 0xa0df, 0xa2df, 0xa0e0, 0xa2e0, 0xa0e1, 0xa2e1, 0xa0e2, 0xa2e2, 0xa0e3, 0xa2e3, 0xa0e4, 0xa2e4, 0xa0e5, 0xa2e5,
0xa0e6, 0xa2e6, 0xa0e7, 0xa2e7, 0xa0e8, 0xa2e8, 0xa0e9, 0xa2e9, 0xa0ea, 0xa2ea, 0xa0eb, 0xa2eb, 0xa0ec, 0xa2ec, 0xa0ed, 0xa2ed,
0xa0ee, 0xa2ee, 0xa0ef, 0xa2ef, 0xa0f0, 0xa2f0, 0xa0f1, 0xa2f1, 0xa0f2, 0xa2f2, 0xa0f3, 0xa2f3, 0xa0f4, 0xa2f4, 0xa0f5, 0xa2f5,
0xa0f6, 0xa2f6, 0xa0f7, 0xa2f7, 0xa0f8, 0xa2f8, 0xa0f9, 0xa2f9, 0xa0fa, 0xa2fa, 0xa0fb, 0xa2fb, 0xa0fc, 0xa2fc, 0xa0fd, 0xa2fd,
0xa0fe, 0xa2fe, 0xa0ff, 0xa2ff, 0xb000, 0xb200, 0xb400, 0xb600, 0xb001, 0xb201, 0xb401, 0xb601, 0xb002, 0xb202, 0xb402, 0xb602,
0xb003, 0xb203, 0xb403, 0xb603, 0xb004, 0xb204, 0xb404, 0xb604, 0xb005, 0xb205, 0xb405, 0xb605, 0xb006, 0xb206, 0xb406, 0xb606,
0xb007, 0xb207, 0xb407, 0xb607, 0xb008, 0xb208, 0xb408, 0xb608, 0xb009, 0xb209, 0xb409, 0xb609, 0xb00a, 0xb20a, 0xb40a, 0xb60a,
0xb00b, 0xb20b, 0xb40b, 0xb60b, 0xb00c, 0xb20c, 0xb40c, 0xb60c, 0xb00d, 0xb20d, 0xb40d, 0xb60d, 0xb00e, 0xb20e, 0xb40e, 0xb60e,
0xb00f, 0xb20f, 0xb40f, 0xb60f, 0xb010, 0xb210, 0xb410, 0xb610, 0xb011, 0xb211, 0xb411, 0xb611, 0xb012, 0xb212, 0xb412, 0xb612,
0xb013, 0xb213, 0xb413, 0xb613, 0xb014, 0xb214, 0xb414, 0xb614, 0xb015, 0xb215, 0xb415, 0xb615, 0xb016, 0xb216, 0xb416, 0xb616,
0xb017, 0xb217, 0xb417, 0xb617, 0xb018, 0xb218, 0xb418, 0xb618, 0xb019, 0xb219, 0xb419, 0xb619, 0xb01a, 0xb21a, 0xb41a, 0xb61a,
0xb01b, 0xb21b, 0xb41b, 0xb61b, 0xb01c, 0xb21c, 0xb41c, 0xb61c, 0xb01d, 0xb21d, 0xb41d, 0xb61d, 0xb01e, 0xb21e, 0xb41e, 0xb61e,
0xb01f, 0xb21f, 0xb41f, 0xb61f, 0xb020, 0xb220, 0xb420, 0xb620, 0xb021, 0xb221, 0xb421, 0xb621, 0xb022, 0xb222, 0xb422, 0xb622,
0xb023, 0xb223, 0xb423, 0xb623, 0xb024, 0xb224, 0xb424, 0xb624, 0xb025, 0xb225, 0xb425, 0xb625, 0xb026, 0xb226, 0xb426, 0xb626,
0xb027, 0xb227, 0xb427, 0xb627, 0xb028, 0xb228, 0xb428, 0xb628, 0xb029, 0xb229, 0xb429, 0xb629, 0xb02a, 0xb22a, 0xb42a, 0xb62a,
0xb02b, 0xb22b, 0xb42b, 0xb62b, 0xb02c, 0xb22c, 0xb42c, 0xb62c, 0xb02d, 0xb22d, 0xb42d, 0xb62d, 0xb02e, 0xb22e, 0xb42e, 0xb62e,
0xb02f, 0xb22f, 0xb42f, 0xb62f, 0xb030, 0xb230, 0xb430, 0xb630, 0xb031, 0xb231, 0xb431, 0xb631, 0xb032, 0xb232, 0xb432, 0xb632,
0xb033, 0xb233, 0xb433, 0xb633, 0xb034, 0xb234, 0xb434, 0xb634, 0xb035, 0xb235, 0xb435, 0xb635, 0xb036, 0xb236, 0xb436, 0xb636,
0xb037, 0xb237, 0xb437, 0xb637, 0xb038, 0xb238, 0xb438, 0xb638, 0xb039, 0xb239, 0xb439, 0xb639, 0xb03a, 0xb23a, 0xb43a, 0xb63a,
0xb03b, 0xb23b, 0xb43b, 0xb63b, 0xb03c, 0xb23c, 0xb43c, 0xb63c, 0xb03d, 0xb23d, 0xb43d, 0xb63d, 0xb03e, 0xb23e, 0xb43e, 0xb63e,
0xb03f, 0xb23f, 0xb43f, 0xb63f, 0xb040, 0xb240, 0xb440, 0xb640, 0xb041, 0xb241, 0xb441, 0xb641, 0xb042, 0xb242, 0xb442, 0xb642,
0xb043, 0xb243, 0xb443, 0xb643, 0xb044, 0xb244, 0xb444, 0xb644, 0xb045, 0xb245, 0xb445, 0xb645, 0xb046, 0xb246, 0xb446, 0xb646,
0xb047, 0xb247, 0xb447, 0xb647, 0xb048, 0xb248, 0xb448, 0xb648, 0xb049, 0xb249, 0xb449, 0xb649, 0xb04a, 0xb24a, 0xb44a, 0xb64a,
0xb04b, 0xb24b, 0xb44b, 0xb64b, 0xb04c, 0xb24c, 0xb44c, 0xb64c, 0xb04d, 0xb24d, 0xb44d, 0xb64d, 0xb04e, 0xb24e, 0xb44e, 0xb64e,
0xb04f, 0xb24f, 0xb44f, 0xb64f, 0xb050, 0xb250, 0xb450, 0xb650, 0xb051, 0xb251, 0xb451, 0xb651, 0xb052, 0xb252, 0xb452, 0xb652,
0xb053, 0xb253, 0xb453, 0xb653, 0xb054, 0xb254, 0xb454, 0xb654, 0xb055, 0xb255, 0xb455, 0xb655, 0xb056, 0xb256, 0xb456, 0xb656,
0xb057, 0xb257, 0xb457, 0xb657, 0xb058, 0xb258, 0xb458, 0xb658, 0xb059, 0xb259, 0xb459, 0xb659, 0xb05a, 0xb25a, 0xb45a, 0xb65a,
0xb05b, 0xb25b, 0xb45b, 0xb65b, 0xb05c, 0xb25c, 0xb45c, 0xb65c, 0xb05d, 0xb25d, 0xb45d, 0xb65d, 0xb05e, 0xb25e, 0xb45e, 0xb65e,
0xb05f, 0xb25f, 0xb45f, 0xb65f, 0xb060, 0xb260, 0xb460, 0xb660, 0xb061, 0xb261, 0xb461, 0xb661, 0xb062, 0xb262, 0xb462, 0xb662,
0xb063, 0xb263, 0xb463, 0xb663, 0xb064, 0xb264, 0xb464, 0xb664, 0xb065, 0xb265, 0xb465, 0xb665, 0xb066, 0xb266, 0xb466, 0xb666,
0xb067, 0xb267, 0xb467, 0xb667, 0xb068, 0xb268, 0xb468, 0xb668, 0xb069, 0xb269, 0xb469, 0xb669, 0xb06a, 0xb26a, 0xb46a, 0xb66a,
0xb06b, 0xb26b, 0xb46b, 0xb66b, 0xb06c, 0xb26c, 0xb46c, 0xb66c, 0xb06d, 0xb26d, 0xb46d, 0xb66d, 0xb06e, 0xb26e, 0xb46e, 0xb66e,
0xb06f, 0xb26f, 0xb46f, 0xb66f, 0xb070, 0xb270, 0xb470, 0xb670, 0xb071, 0xb271, 0xb471, 0xb671, 0xb072, 0xb272, 0xb472, 0xb672,
0xb073, 0xb273, 0xb473, 0xb673, 0xb074, 0xb274, 0xb474, 0xb674, 0xb075, 0xb275, 0xb475, 0xb675, 0xb076, 0xb276, 0xb476, 0xb676,
0xb077, 0xb277, 0xb477, 0xb677, 0xb078, 0xb278, 0xb478, 0xb678, 0xb079, 0xb279, 0xb479, 0xb679, 0xb07a, 0xb27a, 0xb47a, 0xb67a,
0xb07b, 0xb27b, 0xb47b, 0xb67b, 0xb07c, 0xb27c, 0xb47c, 0xb67c, 0xb07d, 0xb27d, 0xb47d, 0xb67d, 0xb07e, 0xb27e, 0xb47e, 0xb67e,
0xb07f, 0xb27f, 0xb47f, 0xb67f };
static const uint16_t crg10[] = { 0xa200, 0xa201, 0xa202, 0xa203, 0xa204, 0xa205, 0xa206, 0xa207, 0xa208, 0xa209, 0xa20a,
0xa20b, 0xa20c, 0xa20d, 0xa20e, 0xa20f, 0xa210, 0xa211, 0xa212, 0xa213, 0xa214, 0xa215, 0xa216, 0xa217, 0xa218, 0xa219, 0xa21a,
0xa21b, 0xa21c, 0xa21d, 0xa21e, 0xa21f, 0xa220, 0xa221, 0xa222, 0xa223, 0xa224, 0xa225, 0xa226, 0xa227, 0xa228, 0xa229, 0xa22a,
0xa22b, 0xa22c, 0xa22d, 0xa22e, 0xa22f, 0xa230, 0xa231, 0xa232, 0xa233, 0xa234, 0xa235, 0xa236, 0xa237, 0xa238, 0xa239, 0xa23a,
0xa23b, 0xa23c, 0xa23d, 0xa23e, 0xa23f, 0xa240, 0xa241, 0xa242, 0xa243, 0xa244, 0xa245, 0xa246, 0xa247, 0xa248, 0xa249, 0xa24a,
0xa24b, 0xa24c, 0xa24d, 0xa24e, 0xa24f, 0xa250, 0xa251, 0xa252, 0xa253, 0xa254, 0xa255, 0xa256, 0xa257, 0xa258, 0xa259, 0xa25a,
0xa25b, 0xa25c, 0xa25d, 0xa25e, 0xa25f, 0xa260, 0xa261, 0xa262, 0xa263, 0xa264, 0xa265, 0xa266, 0xa267, 0xa268, 0xa269, 0xa26a,
0xa26b, 0xa26c, 0xa26d, 0xa26e, 0xa26f, 0xa270, 0xa271, 0xa272, 0xa273, 0xa274, 0xa275, 0xa276, 0xa277, 0xa278, 0xa279, 0xa27a,
0xa27b, 0xa27c, 0xa27d, 0xa27e, 0xa27f, 0xa280, 0xa281, 0xa282, 0xa283, 0xa284, 0xa285, 0xa286, 0xa287, 0xa288, 0xa289, 0xa28a,
0xa28b, 0xa28c, 0xa28d, 0xa28e, 0xa28f, 0xa290, 0xa291, 0xa292, 0xa293, 0xa294, 0xa295, 0xa296, 0xa297, 0xa298, 0xa299, 0xa29a,
0xa29b, 0xa29c, 0xa29d, 0xa29e, 0xa29f, 0xa2a0, 0xa2a1, 0xa2a2, 0xa2a3, 0xa2a4, 0xa2a5, 0xa2a6, 0xa2a7, 0xa2a8, 0xa2a9, 0xa2aa,
0xa2ab, 0xa2ac, 0xa2ad, 0xa2ae, 0xa2af, 0xa2b0, 0xa2b1, 0xa2b2, 0xa2b3, 0xa2b4, 0xa2b5, 0xa2b6, 0xa2b7, 0xa2b8, 0xa2b9, 0xa2ba,
0xa2bb, 0xa2bc, 0xa2bd, 0xa2be, 0xa2bf, 0xa2c0, 0xa2c1, 0xa2c2, 0xa2c3, 0xa2c4, 0xa2c5, 0xa2c6, 0xa2c7, 0xa2c8, 0xa2c9, 0xa2ca,
0xa2cb, 0xa2cc, 0xa2cd, 0xa2ce, 0xa2cf, 0xa2d0, 0xa2d1, 0xa2d2, 0xa2d3, 0xa2d4, 0xa2d5, 0xa2d6, 0xa2d7, 0xa2d8, 0xa2d9, 0xa2da,
0xa2db, 0xa2dc, 0xa2dd, 0xa2de, 0xa2df, 0xa2e0, 0xa2e1, 0xa2e2, 0xa2e3, 0xa2e4, 0xa2e5, 0xa2e6, 0xa2e7, 0xa2e8, 0xa2e9, 0xa2ea,
0xa2eb, 0xa2ec, 0xa2ed, 0xa2ee, 0xa2ef, 0xa2f0, 0xa2f1, 0xa2f2, 0xa2f3, 0xa2f4, 0xa2f5, 0xa2f6, 0xa2f7, 0xa2f8, 0xa2f9, 0xa2fa,
0xa2fb, 0xa2fc, 0xa2fd, 0xa2fe, 0xa2ff, 0xa300, 0xa301, 0xa302, 0xa303, 0xa304, 0xa305, 0xa306, 0xa307, 0xa308, 0xa309, 0xa30a,
0xa30b, 0xa30c, 0xa30d, 0xa30e, 0xa30f, 0xa310, 0xa311, 0xa312, 0xa313, 0xa314, 0xa315, 0xa316, 0xa317, 0xa318, 0xa319, 0xa31a,
0xa31b, 0xa31c, 0xa31d, 0xa31e, 0xa31f, 0xa320, 0xa321, 0xa322, 0xa323, 0xa324, 0xa325, 0xa326, 0xa327, 0xa328, 0xa329, 0xa32a,
0xa32b, 0xa32c, 0xa32d, 0xa32e, 0xa32f, 0xa330, 0xa331, 0xa332, 0xa333, 0xa334, 0xa335, 0xa336, 0xa337, 0xa338, 0xa339, 0xa33a,
0xa33b, 0xa33c, 0xa33d, 0xa33e, 0xa33f, 0xa340, 0xa341, 0xa342, 0xa343, 0xa344, 0xa345, 0xa346, 0xa347, 0xa348, 0xa349, 0xa34a,
0xa34b, 0xa34c, 0xa34d, 0xa34e, 0xa34f, 0xa350, 0xa351, 0xa352, 0xa353, 0xa354, 0xa355, 0xa356, 0xa357, 0xa358, 0xa359, 0xa35a,
0xa35b, 0xa35c, 0xa35d, 0xa35e, 0xa35f, 0xa360, 0xa361, 0xa362, 0xa363, 0xa364, 0xa365, 0xa366, 0xa367, 0xa368, 0xa369, 0xa36a,
0xa36b, 0xa36c, 0xa36d, 0xa36e, 0xa36f, 0xa370, 0xa371, 0xa372, 0xa373, 0xa374, 0xa375, 0xa376, 0xa377, 0xa378, 0xa379, 0xa37a,
0xa37b, 0xa37c, 0xa37d, 0xa37e, 0xa37f, 0xa380, 0xa381, 0xa382, 0xa383, 0xa384, 0xa385, 0xa386, 0xa387, 0xa388, 0xa389, 0xa38a,
0xa38b, 0xa38c, 0xa38d, 0xa38e, 0xa38f, 0xa390, 0xa391, 0xa392, 0xa393, 0xa394, 0xa395, 0xa396, 0xa397, 0xa398, 0xa399, 0xa39a,
0xa39b, 0xa39c, 0xa39d, 0xa39e, 0xa39f, 0xa3a0, 0xa3a1, 0xa3a2, 0xa3a3, 0xa3a4, 0xa3a5, 0xa3a6, 0xa3a7, 0xa3a8, 0xa3a9, 0xa3aa,
0xa3ab, 0xa3ac, 0xa3ad, 0xa3ae, 0xa3af, 0xa3b0, 0xa3b1, 0xa3b2, 0xa3b3, 0xa3b4, 0xa3b5, 0xa3b6, 0xa3b7, 0xa3b8, 0xa3b9, 0xa3ba,
0xa3bb, 0xa3bc, 0xa3bd, 0xa3be, 0xa3bf, 0xa3c0, 0xa3c1, 0xa3c2, 0xa3c3, 0xa3c4, 0xa3c5, 0xa3c6, 0xa3c7, 0xa3c8, 0xa3c9, 0xa3ca,
0xa3cb, 0xa3cc, 0xa3cd, 0xa3ce, 0xa3cf, 0xa3d0, 0xa3d1, 0xa3d2, 0xa3d3, 0xa3d4, 0xa3d5, 0xa3d6, 0xa3d7, 0xa3d8, 0xa3d9, 0xa3da,
0xa3db, 0xa3dc, 0xa3dd, 0xa3de, 0xa3df, 0xa3e0, 0xa3e1, 0xa3e2, 0xa3e3, 0xa3e4, 0xa3e5, 0xa3e6, 0xa3e7, 0xa3e8, 0xa3e9, 0xa3ea,
0xa3eb, 0xa3ec, 0xa3ed, 0xa3ee, 0xa3ef, 0xa3f0, 0xa3f1, 0xa3f2, 0xa3f3, 0xa3f4, 0xa3f5, 0xa3f6, 0xa3f7, 0xa3f8, 0xa3f9, 0xa3fa,
0xa3fb, 0xa3fc, 0xa3fd, 0xa3fe, 0xa3ff, 0xb100, 0xb500, 0xb101, 0xb501, 0xb102, 0xb502, 0xb103, 0xb503, 0xb104, 0xb504, 0xb105,
0xb505, 0xb106, 0xb506, 0xb107, 0xb507, 0xb108, 0xb508, 0xb109, 0xb509, 0xb10a, 0xb50a, 0xb10b, 0xb50b, 0xb10c, 0xb50c, 0xb10d,
0xb50d, 0xb10e, 0xb50e, 0xb10f, 0xb50f, 0xb110, 0xb510, 0xb111, 0xb511, 0xb112, 0xb512, 0xb113, 0xb513, 0xb114, 0xb514, 0xb115,
0xb515, 0xb116, 0xb516, 0xb117, 0xb517, 0xb118, 0xb518, 0xb119, 0xb519, 0xb11a, 0xb51a, 0xb11b, 0xb51b, 0xb11c, 0xb51c, 0xb11d,
0xb51d, 0xb11e, 0xb51e, 0xb11f, 0xb51f, 0xb120, 0xb520, 0xb121, 0xb521, 0xb122, 0xb522, 0xb123, 0xb523, 0xb124, 0xb524, 0xb125,
0xb525, 0xb126, 0xb526, 0xb127, 0xb527, 0xb128, 0xb528, 0xb129, 0xb529, 0xb12a, 0xb52a, 0xb12b, 0xb52b, 0xb12c, 0xb52c, 0xb12d,
0xb52d, 0xb12e, 0xb52e, 0xb12f, 0xb52f, 0xb130, 0xb530, 0xb131, 0xb531, 0xb132, 0xb532, 0xb133, 0xb533, 0xb134, 0xb534, 0xb135,
0xb535, 0xb136, 0xb536, 0xb137, 0xb537, 0xb138, 0xb538, 0xb139, 0xb539, 0xb13a, 0xb53a, 0xb13b, 0xb53b, 0xb13c, 0xb53c, 0xb13d,
0xb53d, 0xb13e, 0xb53e, 0xb13f, 0xb53f, 0xb140, 0xb540, 0xb141, 0xb541, 0xb142, 0xb542, 0xb143, 0xb543, 0xb144, 0xb544, 0xb145,
0xb545, 0xb146, 0xb546, 0xb147, 0xb547, 0xb148, 0xb548, 0xb149, 0xb549, 0xb14a, 0xb54a, 0xb14b, 0xb54b, 0xb14c, 0xb54c, 0xb14d,
0xb54d, 0xb14e, 0xb54e, 0xb14f, 0xb54f, 0xb150, 0xb550, 0xb151, 0xb551, 0xb152, 0xb552, 0xb153, 0xb553, 0xb154, 0xb554, 0xb155,
0xb555, 0xb156, 0xb556, 0xb157, 0xb557, 0xb158, 0xb558, 0xb159, 0xb559, 0xb15a, 0xb55a, 0xb15b, 0xb55b, 0xb15c, 0xb55c, 0xb15d,
0xb55d, 0xb15e, 0xb55e, 0xb15f, 0xb55f, 0xb160, 0xb560, 0xb161, 0xb561, 0xb162, 0xb562, 0xb163, 0xb563, 0xb164, 0xb564, 0xb165,
0xb565, 0xb166, 0xb566, 0xb167, 0xb567, 0xb168, 0xb568, 0xb169, 0xb569, 0xb16a, 0xb56a, 0xb16b, 0xb56b, 0xb16c, 0xb56c, 0xb16d,
0xb56d, 0xb16e, 0xb56e, 0xb16f, 0xb56f, 0xb170, 0xb570, 0xb171, 0xb571, 0xb172, 0xb572, 0xb173, 0xb573, 0xb174, 0xb574, 0xb175,
0xb575, 0xb176, 0xb576, 0xb177, 0xb577, 0xb178, 0xb578, 0xb179, 0xb579, 0xb17a, 0xb57a, 0xb17b, 0xb57b, 0xb17c, 0xb57c, 0xb17d,
0xb57d, 0xb17e, 0xb57e, 0xb17f, 0xb57f, 0xb180, 0xb580, 0xb181, 0xb581, 0xb182, 0xb582, 0xb183, 0xb583, 0xb184, 0xb584, 0xb185,
0xb585, 0xb186, 0xb586, 0xb187, 0xb587, 0xb188, 0xb588, 0xb189, 0xb589, 0xb18a, 0xb58a, 0xb18b, 0xb58b, 0xb18c, 0xb58c, 0xb18d,
0xb58d, 0xb18e, 0xb58e, 0xb18f, 0xb58f, 0xb190, 0xb590, 0xb191, 0xb591, 0xb192, 0xb592, 0xb193, 0xb593, 0xb194, 0xb594, 0xb195,
0xb595, 0xb196, 0xb596, 0xb197, 0xb597, 0xb198, 0xb598, 0xb199, 0xb599, 0xb19a, 0xb59a, 0xb19b, 0xb59b, 0xb19c, 0xb59c, 0xb19d,
0xb59d, 0xb19e, 0xb59e, 0xb19f, 0xb59f, 0xb1a0, 0xb5a0, 0xb1a1, 0xb5a1, 0xb1a2, 0xb5a2, 0xb1a3, 0xb5a3, 0xb1a4, 0xb5a4, 0xb1a5,
0xb5a5, 0xb1a6, 0xb5a6, 0xb1a7, 0xb5a7, 0xb1a8, 0xb5a8, 0xb1a9, 0xb5a9, 0xb1aa, 0xb5aa, 0xb1ab, 0xb5ab, 0xb1ac, 0xb5ac, 0xb1ad,
0xb5ad, 0xb1ae, 0xb5ae, 0xb1af, 0xb5af, 0xb1b0, 0xb5b0, 0xb1b1, 0xb5b1, 0xb1b2, 0xb5b2, 0xb1b3, 0xb5b3, 0xb1b4, 0xb5b4, 0xb1b5,
0xb5b5, 0xb1b6, 0xb5b6, 0xb1b7, 0xb5b7, 0xb1b8, 0xb5b8, 0xb1b9, 0xb5b9, 0xb1ba, 0xb5ba, 0xb1bb, 0xb5bb, 0xb1bc, 0xb5bc, 0xb1bd,
0xb5bd, 0xb1be, 0xb5be, 0xb1bf, 0xb5bf, 0xb1c0, 0xb5c0, 0xb1c1, 0xb5c1, 0xb1c2, 0xb5c2, 0xb1c3, 0xb5c3, 0xb1c4, 0xb5c4, 0xb1c5,
0xb5c5, 0xb1c6, 0xb5c6, 0xb1c7, 0xb5c7, 0xb1c8, 0xb5c8, 0xb1c9, 0xb5c9, 0xb1ca, 0xb5ca, 0xb1cb, 0xb5cb, 0xb1cc, 0xb5cc, 0xb1cd,
0xb5cd, 0xb1ce, 0xb5ce, 0xb1cf, 0xb5cf, 0xb1d0, 0xb5d0, 0xb1d1, 0xb5d1, 0xb1d2, 0xb5d2, 0xb1d3, 0xb5d3, 0xb1d4, 0xb5d4, 0xb1d5,
0xb5d5, 0xb1d6, 0xb5d6, 0xb1d7, 0xb5d7, 0xb1d8, 0xb5d8, 0xb1d9, 0xb5d9, 0xb1da, 0xb5da, 0xb1db, 0xb5db, 0xb1dc, 0xb5dc, 0xb1dd,
0xb5dd, 0xb1de, 0xb5de, 0xb1df, 0xb5df, 0xb1e0, 0xb5e0, 0xb1e1, 0xb5e1, 0xb1e2, 0xb5e2, 0xb1e3, 0xb5e3, 0xb1e4, 0xb5e4, 0xb1e5,
0xb5e5, 0xb1e6, 0xb5e6, 0xb1e7, 0xb5e7, 0xb1e8, 0xb5e8, 0xb1e9, 0xb5e9, 0xb1ea, 0xb5ea, 0xb1eb, 0xb5eb, 0xb1ec, 0xb5ec, 0xb1ed,
0xb5ed, 0xb1ee, 0xb5ee, 0xb1ef, 0xb5ef, 0xb1f0, 0xb5f0, 0xb1f1, 0xb5f1, 0xb1f2, 0xb5f2, 0xb1f3, 0xb5f3, 0xb1f4, 0xb5f4, 0xb1f5,
0xb5f5, 0xb1f6, 0xb5f6, 0xb1f7, 0xb5f7, 0xb1f8, 0xb5f8, 0xb1f9, 0xb5f9, 0xb1fa, 0xb5fa, 0xb1fb, 0xb5fb, 0xb1fc, 0xb5fc, 0xb1fd,
0xb5fd, 0xb1fe, 0xb5fe, 0xb1ff, 0xb5ff, 0xc000, 0xc400, 0xc800, 0xcc00, 0xc001, 0xc401, 0xc801, 0xcc01, 0xc002, 0xc402, 0xc802,
0xcc02, 0xc003, 0xc403, 0xc803, 0xcc03, 0xc004, 0xc404, 0xc804, 0xcc04, 0xc005, 0xc405, 0xc805, 0xcc05, 0xc006, 0xc406, 0xc806,
0xcc06, 0xc007, 0xc407, 0xc807, 0xcc07, 0xc008, 0xc408, 0xc808, 0xcc08, 0xc009, 0xc409, 0xc809, 0xcc09, 0xc00a, 0xc40a, 0xc80a,
0xcc0a, 0xc00b, 0xc40b, 0xc80b, 0xcc0b, 0xc00c, 0xc40c, 0xc80c, 0xcc0c, 0xc00d, 0xc40d, 0xc80d, 0xcc0d, 0xc00e, 0xc40e, 0xc80e,
0xcc0e, 0xc00f, 0xc40f, 0xc80f, 0xcc0f, 0xc010, 0xc410, 0xc810, 0xcc10, 0xc011, 0xc411, 0xc811, 0xcc11, 0xc012, 0xc412, 0xc812,
0xcc12, 0xc013, 0xc413, 0xc813, 0xcc13, 0xc014, 0xc414, 0xc814, 0xcc14, 0xc015, 0xc415, 0xc815, 0xcc15, 0xc016, 0xc416, 0xc816,
0xcc16, 0xc017, 0xc417, 0xc817, 0xcc17, 0xc018, 0xc418, 0xc818, 0xcc18, 0xc019, 0xc419, 0xc819, 0xcc19, 0xc01a, 0xc41a, 0xc81a,
0xcc1a, 0xc01b, 0xc41b, 0xc81b, 0xcc1b, 0xc01c, 0xc41c, 0xc81c, 0xcc1c, 0xc01d, 0xc41d, 0xc81d, 0xcc1d, 0xc01e, 0xc41e, 0xc81e,
0xcc1e, 0xc01f, 0xc41f, 0xc81f, 0xcc1f, 0xc020, 0xc420, 0xc820, 0xcc20, 0xc021, 0xc421, 0xc821, 0xcc21, 0xc022, 0xc422, 0xc822,
0xcc22, 0xc023, 0xc423, 0xc823, 0xcc23, 0xc024, 0xc424, 0xc824, 0xcc24, 0xc025, 0xc425, 0xc825, 0xcc25, 0xc026, 0xc426, 0xc826,
0xcc26, 0xc027, 0xc427, 0xc827, 0xcc27, 0xc028, 0xc428, 0xc828, 0xcc28, 0xc029, 0xc429, 0xc829, 0xcc29, 0xc02a, 0xc42a, 0xc82a,
0xcc2a, 0xc02b, 0xc42b, 0xc82b, 0xcc2b, 0xc02c, 0xc42c, 0xc82c, 0xcc2c, 0xc02d, 0xc42d, 0xc82d, 0xcc2d, 0xc02e, 0xc42e, 0xc82e,
0xcc2e, 0xc02f, 0xc42f, 0xc82f, 0xcc2f, 0xc030, 0xc430, 0xc830, 0xcc30, 0xc031, 0xc431, 0xc831, 0xcc31, 0xc032, 0xc432, 0xc832,
0xcc32, 0xc033, 0xc433, 0xc833, 0xcc33, 0xc034, 0xc434, 0xc834, 0xcc34, 0xc035, 0xc435, 0xc835, 0xcc35, 0xc036, 0xc436, 0xc836,
0xcc36, 0xc037, 0xc437, 0xc837, 0xcc37, 0xc038, 0xc438, 0xc838, 0xcc38, 0xc039, 0xc439, 0xc839, 0xcc39, 0xc03a, 0xc43a, 0xc83a,
0xcc3a, 0xc03b, 0xc43b, 0xc83b, 0xcc3b, 0xc03c, 0xc43c, 0xc83c, 0xcc3c, 0xc03d, 0xc43d, 0xc83d, 0xcc3d, 0xc03e, 0xc43e, 0xc83e,
0xcc3e, 0xc03f, 0xc43f, 0xc83f, 0xcc3f, 0xc040, 0xc440, 0xc840, 0xcc40, 0xc041, 0xc441, 0xc841, 0xcc41, 0xc042, 0xc442, 0xc842,
0xcc42, 0xc043, 0xc443, 0xc843, 0xcc43, 0xc044, 0xc444, 0xc844, 0xcc44, 0xc045, 0xc445, 0xc845, 0xcc45, 0xc046, 0xc446, 0xc846,
0xcc46, 0xc047, 0xc447, 0xc847, 0xcc47, 0xc048, 0xc448, 0xc848, 0xcc48, 0xc049, 0xc449, 0xc849, 0xcc49, 0xc04a, 0xc44a, 0xc84a,
0xcc4a, 0xc04b, 0xc44b, 0xc84b, 0xcc4b, 0xc04c, 0xc44c, 0xc84c, 0xcc4c, 0xc04d, 0xc44d, 0xc84d, 0xcc4d, 0xc04e, 0xc44e, 0xc84e,
0xcc4e, 0xc04f, 0xc44f, 0xc84f, 0xcc4f, 0xc050, 0xc450, 0xc850, 0xcc50, 0xc051, 0xc451, 0xc851, 0xcc51, 0xc052, 0xc452, 0xc852,
0xcc52, 0xc053, 0xc453, 0xc853, 0xcc53, 0xc054, 0xc454, 0xc854, 0xcc54, 0xc055, 0xc455, 0xc855, 0xcc55, 0xc056, 0xc456, 0xc856,
0xcc56, 0xc057, 0xc457, 0xc857, 0xcc57, 0xc058, 0xc458, 0xc858, 0xcc58, 0xc059, 0xc459, 0xc859, 0xcc59, 0xc05a, 0xc45a, 0xc85a,
0xcc5a, 0xc05b, 0xc45b, 0xc85b, 0xcc5b, 0xc05c, 0xc45c, 0xc85c, 0xcc5c, 0xc05d, 0xc45d, 0xc85d, 0xcc5d, 0xc05e, 0xc45e, 0xc85e,
0xcc5e, 0xc05f, 0xc45f, 0xc85f, 0xcc5f, 0xc060, 0xc460, 0xc860, 0xcc60, 0xc061, 0xc461, 0xc861, 0xcc61, 0xc062, 0xc462, 0xc862,
0xcc62, 0xc063, 0xc463, 0xc863, 0xcc63, 0xc064, 0xc464, 0xc864, 0xcc64, 0xc065, 0xc465, 0xc865, 0xcc65, 0xc066, 0xc466, 0xc866,
0xcc66, 0xc067, 0xc467, 0xc867, 0xcc67, 0xc068, 0xc468, 0xc868, 0xcc68, 0xc069, 0xc469, 0xc869, 0xcc69, 0xc06a, 0xc46a, 0xc86a,
0xcc6a, 0xc06b, 0xc46b, 0xc86b, 0xcc6b, 0xc06c, 0xc46c, 0xc86c, 0xcc6c, 0xc06d, 0xc46d, 0xc86d, 0xcc6d, 0xc06e, 0xc46e, 0xc86e,
0xcc6e, 0xc06f, 0xc46f, 0xc86f, 0xcc6f, 0xc070, 0xc470, 0xc870, 0xcc70, 0xc071, 0xc471, 0xc871, 0xcc71, 0xc072, 0xc472, 0xc872,
0xcc72, 0xc073, 0xc473, 0xc873, 0xcc73, 0xc074, 0xc474, 0xc874, 0xcc74, 0xc075, 0xc475, 0xc875, 0xcc75, 0xc076, 0xc476, 0xc876,
0xcc76, 0xc077, 0xc477, 0xc877, 0xcc77, 0xc078, 0xc478, 0xc878, 0xcc78, 0xc079, 0xc479, 0xc879, 0xcc79, 0xc07a, 0xc47a, 0xc87a,
0xcc7a, 0xc07b, 0xc47b, 0xc87b, 0xcc7b, 0xc07c, 0xc47c, 0xc87c, 0xcc7c, 0xc07d, 0xc47d, 0xc87d, 0xcc7d, 0xc07e, 0xc47e, 0xc87e,
0xcc7e, 0xc07f, 0xc47f, 0xc87f, 0xcc7f, 0xc080, 0xc480, 0xc880, 0xcc80, 0xc081, 0xc481, 0xc881, 0xcc81, 0xc082, 0xc482, 0xc882,
0xcc82, 0xc083, 0xc483, 0xc883, 0xcc83, 0xc084, 0xc484, 0xc884, 0xcc84, 0xc085, 0xc485, 0xc885, 0xcc85, 0xc086, 0xc486, 0xc886,
0xcc86, 0xc087, 0xc487, 0xc887, 0xcc87, 0xc088, 0xc488, 0xc888, 0xcc88, 0xc089, 0xc489, 0xc889, 0xcc89, 0xc08a, 0xc48a, 0xc88a,
0xcc8a, 0xc08b, 0xc48b, 0xc88b, 0xcc8b, 0xc08c, 0xc48c, 0xc88c, 0xcc8c, 0xc08d, 0xc48d, 0xc88d, 0xcc8d, 0xc08e, 0xc48e, 0xc88e,
0xcc8e, 0xc08f, 0xc48f, 0xc88f, 0xcc8f, 0xc090, 0xc490, 0xc890, 0xcc90, 0xc091, 0xc491, 0xc891, 0xcc91, 0xc092, 0xc492, 0xc892,
0xcc92, 0xc093, 0xc493, 0xc893, 0xcc93, 0xc094, 0xc494, 0xc894, 0xcc94, 0xc095, 0xc495, 0xc895, 0xcc95, 0xc096, 0xc496, 0xc896,
0xcc96, 0xc097, 0xc497, 0xc897, 0xcc97, 0xc098, 0xc498, 0xc898, 0xcc98, 0xc099, 0xc499, 0xc899, 0xcc99, 0xc09a, 0xc49a, 0xc89a,
0xcc9a, 0xc09b, 0xc49b, 0xc89b, 0xcc9b, 0xc09c, 0xc49c, 0xc89c, 0xcc9c, 0xc09d, 0xc49d, 0xc89d, 0xcc9d, 0xc09e, 0xc49e, 0xc89e,
0xcc9e, 0xc09f, 0xc49f, 0xc89f, 0xcc9f, 0xc0a0, 0xc4a0, 0xc8a0, 0xcca0, 0xc0a1, 0xc4a1, 0xc8a1, 0xcca1, 0xc0a2, 0xc4a2, 0xc8a2,
0xcca2, 0xc0a3, 0xc4a3, 0xc8a3, 0xcca3, 0xc0a4, 0xc4a4, 0xc8a4, 0xcca4, 0xc0a5, 0xc4a5, 0xc8a5, 0xcca5, 0xc0a6, 0xc4a6, 0xc8a6,
0xcca6, 0xc0a7, 0xc4a7, 0xc8a7, 0xcca7, 0xc0a8, 0xc4a8, 0xc8a8, 0xcca8, 0xc0a9, 0xc4a9, 0xc8a9, 0xcca9, 0xc0aa, 0xc4aa, 0xc8aa,
0xccaa, 0xc0ab, 0xc4ab, 0xc8ab, 0xccab, 0xc0ac, 0xc4ac, 0xc8ac, 0xccac, 0xc0ad, 0xc4ad, 0xc8ad, 0xccad, 0xc0ae, 0xc4ae, 0xc8ae,
0xccae, 0xc0af, 0xc4af, 0xc8af, 0xccaf, 0xc0b0, 0xc4b0, 0xc8b0, 0xccb0, 0xc0b1, 0xc4b1, 0xc8b1, 0xccb1, 0xc0b2, 0xc4b2, 0xc8b2,
0xccb2, 0xc0b3, 0xc4b3, 0xc8b3, 0xccb3, 0xc0b4, 0xc4b4, 0xc8b4, 0xccb4, 0xc0b5, 0xc4b5, 0xc8b5, 0xccb5, 0xc0b6, 0xc4b6, 0xc8b6,
0xccb6, 0xc0b7, 0xc4b7, 0xc8b7, 0xccb7, 0xc0b8, 0xc4b8, 0xc8b8, 0xccb8, 0xc0b9, 0xc4b9, 0xc8b9, 0xccb9, 0xc0ba, 0xc4ba, 0xc8ba,
0xccba, 0xc0bb, 0xc4bb, 0xc8bb, 0xccbb, 0xc0bc, 0xc4bc, 0xc8bc, 0xccbc, 0xc0bd, 0xc4bd, 0xc8bd, 0xccbd, 0xc0be, 0xc4be, 0xc8be,
0xccbe, 0xc0bf, 0xc4bf, 0xc8bf, 0xccbf, 0xc0c0, 0xc4c0, 0xc8c0, 0xccc0, 0xc0c1, 0xc4c1, 0xc8c1, 0xccc1, 0xc0c2, 0xc4c2, 0xc8c2,
0xccc2, 0xc0c3, 0xc4c3, 0xc8c3, 0xccc3, 0xc0c4, 0xc4c4, 0xc8c4, 0xccc4, 0xc0c5, 0xc4c5, 0xc8c5, 0xccc5, 0xc0c6, 0xc4c6, 0xc8c6,
0xccc6, 0xc0c7, 0xc4c7, 0xc8c7, 0xccc7, 0xc0c8, 0xc4c8, 0xc8c8, 0xccc8, 0xc0c9, 0xc4c9, 0xc8c9, 0xccc9, 0xc0ca, 0xc4ca, 0xc8ca,
0xccca, 0xc0cb, 0xc4cb, 0xc8cb, 0xcccb, 0xc0cc, 0xc4cc, 0xc8cc, 0xcccc, 0xc0cd, 0xc4cd, 0xc8cd, 0xcccd, 0xc0ce, 0xc4ce, 0xc8ce,
0xccce, 0xc0cf, 0xc4cf, 0xc8cf, 0xcccf, 0xc0d0, 0xc4d0, 0xc8d0, 0xccd0, 0xc0d1, 0xc4d1, 0xc8d1, 0xccd1, 0xc0d2, 0xc4d2, 0xc8d2,
0xccd2, 0xc0d3, 0xc4d3, 0xc8d3, 0xccd3, 0xc0d4, 0xc4d4, 0xc8d4, 0xccd4, 0xc0d5, 0xc4d5, 0xc8d5, 0xccd5, 0xc0d6, 0xc4d6, 0xc8d6,
0xccd6, 0xc0d7, 0xc4d7, 0xc8d7, 0xccd7, 0xc0d8, 0xc4d8, 0xc8d8, 0xccd8, 0xc0d9, 0xc4d9, 0xc8d9, 0xccd9, 0xc0da, 0xc4da, 0xc8da,
0xccda, 0xc0db, 0xc4db, 0xc8db, 0xccdb, 0xc0dc, 0xc4dc, 0xc8dc, 0xccdc, 0xc0dd, 0xc4dd, 0xc8dd, 0xccdd, 0xc0de, 0xc4de, 0xc8de,
0xccde, 0xc0df, 0xc4df, 0xc8df, 0xccdf, 0xc0e0, 0xc4e0, 0xc8e0, 0xcce0, 0xc0e1, 0xc4e1, 0xc8e1, 0xcce1, 0xc0e2, 0xc4e2, 0xc8e2,
0xcce2, 0xc0e3, 0xc4e3, 0xc8e3, 0xcce3, 0xc0e4, 0xc4e4, 0xc8e4, 0xcce4, 0xc0e5, 0xc4e5, 0xc8e5, 0xcce5, 0xc0e6, 0xc4e6, 0xc8e6,
0xcce6, 0xc0e7, 0xc4e7, 0xc8e7, 0xcce7, 0xc0e8, 0xc4e8, 0xc8e8, 0xcce8, 0xc0e9, 0xc4e9, 0xc8e9, 0xcce9, 0xc0ea, 0xc4ea, 0xc8ea,
0xccea, 0xc0eb, 0xc4eb, 0xc8eb, 0xcceb, 0xc0ec, 0xc4ec, 0xc8ec, 0xccec, 0xc0ed, 0xc4ed, 0xc8ed, 0xcced, 0xc0ee, 0xc4ee, 0xc8ee,
0xccee, 0xc0ef, 0xc4ef, 0xc8ef, 0xccef, 0xc0f0, 0xc4f0, 0xc8f0, 0xccf0, 0xc0f1, 0xc4f1, 0xc8f1, 0xccf1, 0xc0f2, 0xc4f2, 0xc8f2,
0xccf2, 0xc0f3, 0xc4f3, 0xc8f3, 0xccf3, 0xc0f4, 0xc4f4, 0xc8f4, 0xccf4, 0xc0f5, 0xc4f5, 0xc8f5, 0xccf5, 0xc0f6, 0xc4f6, 0xc8f6,
0xccf6, 0xc0f7, 0xc4f7, 0xc8f7, 0xccf7, 0xc0f8, 0xc4f8, 0xc8f8, 0xccf8, 0xc0f9, 0xc4f9, 0xc8f9, 0xccf9, 0xc0fa, 0xc4fa, 0xc8fa,
0xccfa, 0xc0fb, 0xc4fb, 0xc8fb, 0xccfb, 0xc0fc, 0xc4fc, 0xc8fc, 0xccfc, 0xc0fd, 0xc4fd, 0xc8fd, 0xccfd, 0xc0fe, 0xc4fe, 0xc8fe,
0xccfe, 0xc0ff, 0xc4ff, 0xc8ff, 0xccff };
static const uint16_t *CRG[] = {nullptr, crg1, crg2, crg3, crg4, crg5, crg6, crg7, crg8, crg9, crg10};
#endif

// Code switch encoding tables, about 256 bytes, stored the same way
// See tables.py for how they are generated
// They are defined for 3 4 5 and 6 bits for unit length. 0x1000 means no change
static const uint16_t csw3[] = {0x1000, 0x3005, 0x4003, 0x5001, 0x5019, 0x5009, 0x400b, 0x3007};
static const uint16_t csw4[] = {0x1000, 0x4009, 0x400d, 0x5005, 0x5007, 0x6001, 0x6021, 0x6003, 0x6033, 0x6013, 0x6031, 0x6011, 
0x5017, 0x5015, 0x400f, 0x400b};
static const uint16_t csw5[] = {0x1000, 0x5011, 0x5015, 0x5019, 0x501d, 0x6009, 0x600b, 0x600d, 0x600f, 0x7001, 0x7041,
0x7003, 0x7043, 0x7005, 0x7045, 0x7007, 0x7067, 0x7027, 0x7065, 0x7025, 0x7063, 0x7023, 0x7061, 0x7021, 0x602f, 0x602d, 0x602b,
0x6029, 0x501f, 0x501b, 0x5017, 0x5013};
static const uint16_t csw6[] = {0x1000, 0x6021, 0x6025, 0x6029, 0x602d, 0x6031, 0x6035, 0x6039, 0x603d, 0x7011, 0x7013,
0x7015, 0x7017, 0x7019, 0x701b, 0x701d, 0x701f, 0x8001, 0x8081, 0x8003, 0x8083, 0x8005, 0x8085, 0x8007, 0x8087, 0x8009, 0x8089,
0x800b, 0x808b, 0x800d, 0x808d, 0x800f, 0x80cf, 0x804f, 0x80cd, 0x804d, 0x80cb, 0x804b, 0x80c9, 0x8049, 0x80c7, 0x8047, 0x80c5,
0x8045, 0x80c3, 0x8043, 0x80c1, 0x8041, 0x705f, 0x705d, 0x705b, 0x7059, 0x7057, 0x7055, 0x7053, 0x7051, 0x603f, 0x603b, 0x6037,
0x6033, 0x602f, 0x602b, 0x6027, 0x6023};
static const uint16_t *CSW[] = {nullptr, nullptr, nullptr, csw3, csw4, csw5, csw6};

// Decoding tables for codeswitch
static const uint16_t dsw3[] = { 0x5003, 0x4002, 0x3001, 0x3007, 0x5005, 0x4006, 0x3001, 0x3007, 0x5004, 0x4002, 0x3001, 
0x3007, 0x5004, 0x4006, 0x3001, 0x3007};
static const uint16_t dsw4[] = { 0x6005, 0x6007, 0x5003, 0x5004, 0x4001, 0x400f, 0x4002, 0x400e, 0x600b, 0x6009, 0x500d,
0x500c, 0x4001, 0x400f, 0x4002, 0x400e, 0x6006, 0x6008, 0x5003, 0x5004, 0x4001, 0x400f, 0x4002, 0x400e, 0x600a, 0x6008, 0x500d,
0x500c, 0x4001, 0x400f, 0x4002, 0x400e};
static const uint16_t dsw5[] = { 0x7009, 0x700b, 0x700d, 0x700f, 0x6005, 0x6006, 0x6007, 0x6008, 0x5001, 0x501f, 0x5002,
0x501e, 0x5003, 0x501d, 0x5004, 0x501c, 0x7017, 0x7015, 0x7013, 0x7011, 0x601b, 0x601a, 0x6019, 0x6018, 0x5001, 0x501f, 0x5002,
0x501e, 0x5003, 0x501d, 0x5004, 0x501c, 0x700a, 0x700c, 0x700e, 0x7010, 0x6005, 0x6006, 0x6007, 0x6008, 0x5001, 0x501f, 0x5002,
0x501e, 0x5003, 0x501d, 0x5004, 0x501c, 0x7016, 0x7014, 0x7012, 0x7010, 0x601b, 0x601a, 0x6019, 0x6018, 0x5001, 0x501f, 0x5002,
0x501e, 0x5003, 0x501d, 0x5004, 0x501c};
static const uint16_t dsw6[] = { 0x8011, 0x8013, 0x8015, 0x8017, 0x8019, 0x801b, 0x801d, 0x801f, 0x7009, 0x700a, 0x700b,
0x700c, 0x700d, 0x700e, 0x700f, 0x7010, 0x6001, 0x603f, 0x6002, 0x603e, 0x6003, 0x603d, 0x6004, 0x603c, 0x6005, 0x603b, 0x6006,
0x603a, 0x6007, 0x6039, 0x6008, 0x6038, 0x802f, 0x802d, 0x802b, 0x8029, 0x8027, 0x8025, 0x8023, 0x8021, 0x7037, 0x7036, 0x7035,
0x7034, 0x7033, 0x7032, 0x7031, 0x7030, 0x6001, 0x603f, 0x6002, 0x603e, 0x6003, 0x603d, 0x6004, 0x603c, 0x6005, 0x603b, 0x6006,
0x603a, 0x6007, 0x6039, 0x6008, 0x6038, 0x8012, 0x8014, 0x8016, 0x8018, 0x801a, 0x801c, 0x801e, 0x8020, 0x7009, 0x700a, 0x700b,
0x700c, 0x700d, 0x700e, 0x700f, 0x7010, 0x6001, 0x603f, 0x6002, 0x603e, 0x6003, 0x603d, 0x6004, 0x603c, 0x6005, 0x603b, 0x6006,
0x603a, 0x6007, 0x6039, 0x6008, 0x6038, 0x802e, 0x802c, 0x802a, 0x8028, 0x8026, 0x8024, 0x8022, 0x8020, 0x7037, 0x7036, 0x7035,
0x7034, 0x7033, 0x7032, 0x7031, 0x7030, 0x6001, 0x603f, 0x6002, 0x603e, 0x6003, 0x603d, 0x6004, 0x603c, 0x6005, 0x603b, 0x6006,
0x603a, 0x6007, 0x6039, 0x6008, 0x6038};
static const uint16_t *DSW[] = {nullptr, nullptr, nullptr, dsw3, dsw4, dsw5, dsw6};

// Encoding with three codeword lenghts, used for higher rungs, not for byte data
// Yes, it's horrid, but it works. Bit fiddling!
// No conditionals, computes all three forms and chooses one by masking with the condition
// It is faster than similar code with conditions because the calculations for the three lines get interleaved
// The "(~0ull * (1 &" is to show the compiler that the multiplication is a mask operation
static std::pair<size_t, uint64_t> q3csz(uint64_t val, size_t rung) {
    uint64_t nxt = (val >> (rung - 1)) & 1;
    uint64_t top = val >> rung;
    // <size, value>
    return std::make_pair<size_t, uint64_t>(rung + top + (top | nxt),
        +((~0ull * (1 & top)) & (((val ^ (1ull << rung)) >> 2) | ((val & 0b11ull) << rung)))   // 1 x BIG     -> 00
        +((~0ull * (1 & ~(top | nxt))) & (val + (1ull << (rung - 1))))                         // 0 0 LITTLE  -> 1?
        +((~0ull * (1 & (~top & nxt))) & (val >> 1 | ((val & 1) << rung))));                   // 0 1 MIDDLE  -> 01
}

// Computed decoding, might be faster with some common factor
static std::pair<size_t, uint64_t> q3d(uint64_t acc, size_t rung) {
    uint64_t ntop = (~(acc >> (rung - 1))) & 1;
    uint64_t nnxt = (~(acc >> (rung - 2))) & 1;
    uint64_t rbit = 1ull << rung;
    return std::make_pair(rung + (ntop & 1) + (ntop & nnxt & 1),
        (1 & ~ntop) * (acc & ((rbit >> 1) - 1))
        + (1 & ntop & ~nnxt) * (((acc << 1) & (rbit - 1)) | ((acc >> rung) & 1))
        + (1 & ntop & nnxt) * (rbit + ((acc & ((rbit >> 1) - 1)) << 2) + ((acc >> rung) & 0b11))
    );
}


template <typename T = uint8_t>
std::vector<uint8_t> encode(const std::vector<T>& image,
    size_t xsize, size_t ysize, int mb = 1)
{
    constexpr size_t B = 4; // Block is 4x4 pixels
    // Unit size bit length
    constexpr size_t UBITS = sizeof(T) == 1 ? 3 : sizeof(T) == 2 ? 4 : sizeof(T) == 4 ? 5 : 6;
    // Elements in a group
    constexpr size_t B2(B * B);

    std::vector<uint8_t> result;
    result.reserve(image.size() * sizeof(T));
    Bitstream s(result);
    const size_t bands = image.size() / xsize / ysize;
    assert(image.size() == xsize * ysize * bands);
    assert(0 == xsize % B && 0 == ysize % B);

    // Running code length, start with nominal value
    std::vector<size_t> runbits(bands, sizeof(T) * 8 - 1);
    std::vector<T> prev(bands, 0u);      // Previous value, per band
    T group[B2];  // Current 2D group to encode, as array
    size_t offsets[B2];
    for (size_t i = 0; i < B2; i++)
        offsets[i] = (xsize * ylut[i] + xlut[i]) * bands;
    for (size_t y = 0; y < ysize; y += B) {
        for (size_t x = 0; x < xsize; x += B) {
            size_t loc = (y * xsize + x) * bands; // Top-left pixel address
            for (size_t c = 0; c < bands; c++) { // blocks are band interleaved

                // Collect the block for this band
                if (mb >= 0 && mb < bands && mb != c) {
                    for (size_t i = 0; i < B2; i++)
                        group[i] = image[loc + offsets[i] + c] - image[loc + offsets[i] + mb];
                }
                else {
                    for (size_t i = 0; i < B2; i++)
                        group[i] = image[loc + offsets[i] + c];
                }

                // Delta in low sign group encode
                prev[c] = dsign(group, prev[c]);
                const uint64_t maxval = *std::max_element(group, group + B2);
                const size_t rung = topbit(maxval | 1); // Force at least one bit set

                // Encode rung switch using tables, works even with no rung change
                uint64_t acc = CSW[UBITS][(rung - runbits[c]) & ((1ull << UBITS) - 1)];
                size_t abits = acc >> 12;
                acc &= 0xff; // Strip the size
                runbits[c] = rung;

                if (0 == rung) { // only 1s and 0s, rung is -1 or 0
                    acc |= maxval << abits++;
                    if (0 != maxval)
                        for (uint64_t v : group)
                            acc |= v << abits++;
                    s.push(acc, abits);
                    continue;
                }

                // If the rung bit sequence is a step down flip the last set bit, it saves one or two bits
                auto p = stepleft(group, rung);
                if (p < B2)
                    group[p] ^= static_cast<T>(1ull << rung);

                if (6 > rung) { // Encoded data fits in 64 or 128 bits
                    auto t = CRG[rung];
                    for (int i = 0; i < B2 / 2; i++) {
                        acc |= (TBLMASK & t[group[i]]) << abits;
                        abits += t[group[i]] >> 12;
                    }

                    // At rung 1 and 2 this push can be skipped, if the accum has enough space
                    if (!((rung == 1) || (rung == 2 && abits < 33))) {
                        s.push(acc, abits);
                        acc = abits = 0;
                    }

                    for (int i = B2 / 2; i < B2; i++) {
                        acc |= (TBLMASK & t[group[i]]) << abits;
                        abits += t[group[i]] >> 12;
                    }
                    s.push(acc, abits);
                    continue;
                }

                // Last part of table encoding, rung 6-7 or 6-10
                // Encoded data fits in 256 bits, 4 way interleaved
                if ((sizeof(CRG)/sizeof(*CRG)) > rung) {
                    auto t = CRG[rung];
                    size_t a[4] = { acc, 0, 0, 0 };
                    size_t asz[4] = { abits, 0, 0, 0 };
                    for (int i = 0; i < B2 / 4; i++)
                        for (int j = 0; j < 4; j++) {
                            uint16_t v = t[group[j * 4 + i]];
                            a[j] |= (TBLMASK & v) << asz[j];
                            asz[j] += v >> 12;
                        }
                    for (int j = 0; j < 4; j++)
                        s.push(a[j], asz[j]);
                    continue;
                }

                // Computed three length encoding, slower, works for rung > 1
                if (1 < sizeof(T)) { // This code vanishes in 8 bit mode
                    // Push the code switch for non-table encoding, not worth the hassle
                    s.push(acc, abits);
                    if (63 != rung) {
                        for (uint64_t val : group) {
                            auto p = q3csz(val, rung);
                            s.push(p.second, p.first);
                        }
                    }
                    else { // rung 63 may overflow 64 bits, push the second val bit explicitly
                        for (uint64_t val : group) {
                            auto p = q3csz(val, rung);
                            size_t ovf = p.first & (p.first >> 6); // overflow flag
                            s.push(p.second, p.first ^ ovf); // changes 65 in 64
                            s.push((val >> 1) & 1, ovf); // safe to call with 0 bits
                        }
                    }
                }
            }
        }
    }
    return result;
}

template<typename T = uint8_t, size_t B = 4>
std::vector<T> decode(std::vector<uint8_t>& src, size_t xsize, size_t ysize, 
    size_t bands, int mb = 1)
{
    std::vector<T> image(xsize * ysize * bands);
    Bitstream s(src);
    std::vector<T> prev(bands, 0);
    // Elements in a group
    constexpr size_t B2(B * B);
    std::vector<T> group(B2);

    // Unit size bit length
    constexpr int UBITS = sizeof(T) == 1 ? 3 : sizeof(T) == 2 ? 4 : sizeof(T) == 4 ? 5 : 6;
    auto dsw = DSW[UBITS];
    std::vector<size_t> runbits(bands, sizeof(T) * 8 - 1);

    std::vector<size_t> offsets(B2);
    for (size_t i = 0; i < B2; i++)
        offsets[i] = (xsize * ylut[i] + xlut[i]) * bands;

    uint64_t acc;
    size_t abits = 0;
    for (size_t y = 0; (y + B) <= ysize; y += B) {
        for (size_t x = 0; (x + B) <= xsize; x += B) {
            size_t loc = (y * xsize + x) * bands;
            for (int c = 0; c < bands; c++) {
                if (0) {
                    if (0 != s.get()) { // The rung change flag, triggers variable size decoding
                        uint8_t cs;
                        s.pull(cs, UBITS - 1);

                        if (cs >= (1ull << (UBITS - 2))) // Starts with 1x, short
                            cs ^= (1ull << (UBITS - 2));
                        else if (cs >= (1ull << (UBITS - 3))) // Starts with 01, middle
                            cs = static_cast<uint8_t>(s.get()) + cs * 2;
                        else { // starts with 00, long
                            uint8_t val;
                            s.pull(val, 2);
                            cs = (cs << 2) + val + (1ull << (UBITS - 1));
                        }

                        // Undo the mags operation
                        cs = smag(cs);
                        // do the positive shift if needed
                        cs += ((cs >> 7) ^ 1);

                        assert(cs != 0); // This is where the in-rung signal can be detected
                        runbits[c] = (runbits[c] + cs) & ((1ull << UBITS) - 1);
                    }
                }
                else {
                    acc = s.peek();
                    abits = 1; // Used bits
                    if (acc & 1) {
                        auto cs = dsw[(acc >> 1) & ((1ull << (UBITS + 1)) - 1)];
                        runbits[c] = (runbits[c] + cs) & ((1ull << UBITS) - 1);
                        abits = static_cast<size_t>(cs >> 12);
                    }
                }

                const size_t rung = runbits[c];
                //printf("%d\n", int(rung));
                uint64_t val;
                if (0 == rung) { // 0 or 1
                    if (0) {
                        if (0 == s.get()) // All 0s
                            fill(group.begin(), group.end(), 0);
                        else { // 0 and 1s
                            s.pull(val, group.size());
                            for (int i = 0; i < B2; i++) {
                                group[i] = val & 1;
                                val >>= 1;
                            }
                        }
                    }
                    else { // Accumulator based
                        if (0 == ((acc >> abits++) & 1))
                            fill(group.begin(), group.end(), 0);
                        else {
                            for (auto& v : group)
                                v = 1 & (acc >> abits++);
                        }
                        s.advance(abits);
                    }
                }
                else if (1 == rung) { // 2 rung nominal, could be a single bit
                    s.advance(abits);
                    for (auto& it : group)
                        if (0 != (it = static_cast<T>(s.get())))
                            if (!(it = static_cast<T>(s.get())))
                                it = static_cast<T>(s.get() | 0b10);
                }
                else { // triple length
                    s.advance(abits);
                    for (auto& it : group) {
                        if (1) {
                            s.pull(it, rung);
                            if (it > mask[rung - 1]) // Starts with 1x
                                it &= mask[rung - 1];
                            else if (it > mask[rung - 2]) // Starts with 01
                                it = static_cast<T>(s.get() + (static_cast<uint64_t>(it) << 1));
                            else { // starts with 00
                                s.pull(val, 2);
                                it = static_cast<T>((1ull << rung) + (static_cast<uint64_t>(it) << 2) + val);
                            }
                        }
                        else {
                            if (sizeof(T) != 8) {
                                auto p = q3d(s.peek(), rung);
                                it = static_cast<T>(p.second);
                                s.advance(p.first);
                            }
                            else {
                                auto acc = s.peek();
                                if (acc & (1ull << (rung - 1))) { // Starts with 1x
                                    it = acc & ((1ull << (rung - 1)) - 1);
                                    s.advance(rung);
                                }
                                else if (acc & (1ull << (rung - 2))) { // Starts with 01
                                    it = ((acc << 1) & ((1ull << rung) - 1)) | ((acc >> rung) & 1);
                                    s.advance(rung + 1);
                                }
                                else { // starts with 00, rung + 2 overflows
                                    if (sizeof(T) != 8) {
                                        it = static_cast<T>(1ull << rung) + ((acc & ((1ull << (rung - 1)) - 1)) << 2) + ((acc >> rung) & 0b11);
                                        s.advance(rung + 2);
                                    }
                                    else { // Safe for overflow due to unit size
                                        if (rung != 63) {
                                            it = static_cast<T>(1ull << rung) | ((acc & (1ull << (rung - 1)) - 1) << 2) | ((acc >> rung) & 0b11);
                                            s.advance(rung + 2);
                                        }
                                        else { // Overflow, bit 1 is not in accumulator
                                            it = static_cast<T>(1ull << rung) | ((acc & (1ull << (rung - 1)) - 1) << 2);
                                            s.advance(63);
                                            s.pull(acc, 2);
                                            it += static_cast<T>(acc);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // Undo the step change
                if (rung > 0 && (0 == (group[B2 - 1] >> rung))) {
                    auto p = stepright(group.data(), rung);
                    if (p < B2)
                        group[p] ^= static_cast<T>(1) << rung;
                }
                prev[c] = undsign(group.data(), prev[c]);
                for (size_t i = 0; i < group.size(); i++)
                    image[loc + c + offsets[i]] = group[i];
            }
            for (int c = 0; c < bands; c++)
                if (mb >= 0 && mb != c)
                    for (size_t i = 0; i < group.size(); i++)
                        image[loc + c + offsets[i]] += image[loc + mb + offsets[i]];
        }
    }
    return image;
}

} // Namespace
