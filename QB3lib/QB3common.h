/*
Content: QB3 parts used by both the encoder and the decoder

Copyright 2020-2025 Esri
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

Contributors:  Lucian Plesea
*/

// This file is only used during library build
// Include the linkage file generated by CMake before QB3.h
#include "libqb3_export.h"
#include "QB3.h"
#include "bitstream.h"
#include <cinttypes>
#include <utility>
#include <type_traits>

#if defined(_WIN32)
#include <intrin.h>
#endif

// Tables have 12bits of data, top 4 bits are size
constexpr auto TBLMASK(0xfffull);

// Block is 4x4 pixels
constexpr size_t B(4);
constexpr size_t B2(B * B);

#if QB3_MAXBANDS > 256
#error QB3_MAXBANDS too large
#endif

#if defined(_WIN32)
// blog2 of val, result is undefined for val == 0
static size_t topbit(uint64_t val) {
    return 63 - __lzcnt64(val);
}
#elif defined(__GNUC__)
static size_t topbit(uint64_t val) {
    return 63 - __builtin_clzll(val);
}
#else // no builtins, portable C
// blog2 of val, result is undefined for val == 0
static size_t topbit(uint64_t v) {
    size_t r, t;
    r = size_t(0 != (v >> 32)) << 5; v >>= r;
    t = size_t(0 != (v >> 16)) << 4; v >>= t; r |= t;
    t = size_t(0 != (v >> 8)) << 3;  v >>= t; r |= t;
    t = size_t(0 != (v >> 4)) << 2;  v >>= t; r |= t;
    return r + ((0xffffaa50ull >> (v << 1)) & 0x3);
}
#endif

struct band_state {
    size_t prev, runbits, cf;
};

// Encoder control structure
struct encs {
    size_t xsize;
    size_t ysize;
    size_t nbands;
    // Line to line stride in type units
    size_t stride;
    // micro block scanning order
    uint64_t order;
    uint64_t quanta;

    // Persistent state by band
    band_state band[QB3_MAXBANDS];
    // band which will be subtracted, by band
    size_t cband[QB3_MAXBANDS];

    int error; // Holds the code for error, 0 if everything is fine

    qb3_mode mode;
    qb3_dtype type;
    bool away; // Round up instead of down when quantizing
};

// Decoder control structure
struct decs {
    size_t xsize;
    size_t ysize;
    size_t nbands;
    // Line to line stride in type units
    size_t stride;
    // micro block scanning order
    uint64_t order;
    uint64_t quanta;
    int error;
    int stage;

    // band which will be added, by band
    uint8_t cband[QB3_MAXBANDS];
    qb3_mode mode;
    qb3_dtype type;

    // Input buffer
    uint8_t* s_in;
    size_t s_size;
};

// in decode.cpp
extern const int typesizes[8];

// Could be a macro
static size_t szof(qb3_dtype dt) {
    return (dt > QB3_I64) ? 0 : typesizes[int(dt)];
}

// Encode integers as magnitude and sign, with bit 0 for sign.
// This encoding has the top bits always zero, regardless of sign
// To keep the range the same as two's complement, the magnitude of 
// negative values is biased down by one (no negative zero)

// Change to mag-sign without conditionals, as fast as C can make it
template<typename T>
static T mags(T v) {
    return (v << 1) ^ (~T(0) * (v >> (8 * sizeof(T) - 1)));
}

// Undo mag-sign without conditionals, as fast as C can make it
template<typename T>
static T smag(T v) {
    return (v >> 1) ^ (~T(0) * (v & 1));
}

// If the rung bits of the input values match 1*0*, returns the index of first 0 + 1
// Assumes at least one rung bit out of B2 is set
// Return > B2 if no match
template<typename T>
static size_t step(const T* const v, size_t rung) {
    uint64_t acc = 0ull;
    // Accumulate flipped rung bits
    for (size_t i = 0; i < B2; i++)
        acc = (acc << 1) | (1 ^ (v[i] >> rung));
    // Looking for 0*1*, with at least one bit set
    bool s = ((acc & (acc + 1)) != 0);
    return B2 + B2 * 2 * s - topbit(acc) -1;
}

// Specialization for 8bit values, loopless, thus faster
template<>
size_t step<uint8_t>(const uint8_t* const v, size_t rung) {
    assert(B2 == 16);
    auto v64 = reinterpret_cast<const uint64_t*>(v);
    auto v1 = v64[0] & (0x0101010101010101ull << rung);
    auto v2 = v64[1] & (0x0101010101010101ull << rung);
    // Accumulate rung bits at the top
    v1 *= 0x2040810204081ull;
    v2 *= 0x2040810204081ull;
    // Shift the valid bits to the right
    uint16_t acc = ((v1 >> (49 + rung)) & 0xff) | ((v2 >> (41 + rung)) & 0xff00);
    // The rung bits are not flipped and they are in LSB order
    bool s = ((acc & (acc + 1)) != 0);
    return s * 16 + topbit(acc) + 1;
}

// QB3 block order, encoded as a single 64bit value
// each nibble holds the adress of a pixel, two bits for x and two bits for y
// Use nibble values in the identity matrix, read in the curve order
/* Identity matrix
0 1 2 3
4 5 6 7
8 9 a b
c d e f
constexpr uint64_t ICURVE(0x0123456789abcdef);
*/

/* The legacy z-curve order
 0 1 4 5
 2 3 6 7
 8 9 c d
 a b e f
*/
constexpr uint64_t ZCURVE(0x0145236789cdabef);

/* Hilbert space filling curve second degree, results in better compression than Z-curve
 0 1 e f
 3 2 d c
 4 7 8 b
 5 6 9 a
*/
constexpr uint64_t HILBERT(0x01548cd9aefb7623);
