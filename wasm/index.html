<!DOCTYPE html>
  <html>
  <head>
    <meta charset=utf-8 />
    <title>QB3 decoder protytype</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />

    <!-- Load Leaflet from CDN-->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet-src.js"></script>

    <!-- load our plugin -->
    <script src="qb3dec.js"></script>

    <script>
        var QB3dec = Module;
        QB3dec.onRuntimeInitialized = () => {

            // char * GetInfo(void *data, size_t sz);
            // important fields are
            // xsize, ysize, nbands, and type
            // type is one of <u>int[8|16|32|64]
            QB3dec.GetInfo = this.cwrap('GetInfo', 'number', ['number', 'number']);

            // size_t decode(void *data, size_t sz, double *out, char *message);
            QB3dec.decode = this.cwrap('decode', 'number', ['number', 'number', 'number', 'number']);

            // Attach the higher level functions
            QB3dec.getInfo = function(data) {
                // Use a small array, to avoid the full size
                if (data.length > 1000)
                    data = data.slice(0, 1000);
                var dataPtr = this._malloc(data.length);
                this.writeArrayToMemory(data, dataPtr);
                let cresult = this.GetInfo(dataPtr, data.length);
                // This is actually a json string
                if (cresult == 0)
                    return null;
                let response = this.UTF8ToString(cresult);
                this._free(dataPtr);
                return JSON.parse(response);
            }

            QB3dec.decodeData = function(data) {
                let image = QB3dec.getInfo(data);
                if (!image) {
                    console.error("Failed to get QB3 raster");
                    return null;
                }
                // Print the image info to console
                // console.log("Image Info:", image);

                // Copy the data to wasm
                rawqb3 = this._malloc(data.length);
                this.writeArrayToMemory(data, rawqb3);

                if (image.dtype != "uint16") {
                    console.error("Unsupported data type: " + image.type);
                    this._free(rawqb3);
                    return null;
                }
                // Image size in bytes
                let imageSize = image.xsize * image.ysize * image.nbands * 2;
                // Allocate the output buffer
                let outPtr = this._malloc(imageSize);
                // Allocate a buffer for the message
                let message = this._malloc(1024);
                decoded = this.decode(rawqb3, data.length, outPtr, message);
                // Free the raw data buffer
                this._free(rawqb3);
                if (decoded == 0) {
                    this._free(outPtr);
                    console.error("Decoding failed: " + this.UTF8ToString(message));
                    this._free(message);
                    return null;
                }
                this._free(message);

                // Copy from a typed view, then release it
                image.data = new Uint16Array(new Uint16Array(this.HEAPU8.buffer, 
                    outPtr, image.xsize * image.ysize * image.nbands));
                this._free(outPtr);
                return image;
        }

        QB3L.addTo(map);
    }
    </script>

    <script>
        var QB3Layer = L.GridLayer.extend({
            createTile: function(coords, done) {
                var error;
                var tile = L.DomUtil.create('canvas', 'leaflet-tile');
                tile.width = this.options.tileSize;
                tile.height = this.options.tileSize;
                tile.zoom = coords.z;

                var xhr = new XMLHttpRequest();
                xhr.responseType = 'arraybuffer';

                var url = 'tile' + '/' + coords.z + '/' + coords.y + '/' + coords.x;
                xhr.open("Get", url, true);
                xhr.send();
                
                xhr.onreadystatechange = function (evt) {
                    if (evt.target.readyState == 4 && evt.target.status == 200) {
                        tile.data = new Uint8Array(evt.target.response);
                        // var data = new Uint8Array(evt.target.response);
                        // tile.image = QB3dec.decodeData(data);
                        if (tile.data)
                          this.draw(tile);
                        else {
                            erro = "Unrecognized QB3 data";
                        }
                        done(error, tile);                        
                    }
                }.bind(this);

                return tile;
            },

            draw: function(tile) {
                if (!tile.data) {
                    console.log("No data to draw");
                    return;
                }

                // Decode the tile data
                // console.time("Decode Tile Data");
                image = QB3dec.decodeData(tile.data);
                // console.timeEnd("Decode Tile Data");
                if (!image) {
                    console.error("Failed to decode tile data");
                    return;
                }

                let width = tile.width;
                let height = tile.height;
                if (image.xsize !== width || image.ysize !== height) {
                    console.error("Tile size mismatch: expected " + width + "x" + height + ", got " + image.xsize + "x" + image.ysize);
                    return;
                }

                let nbands = image.nbands;
                let values = image.data;

                // Verify that the image data has the expected size
                if (values.length !== width * height * nbands) {
                    console.error("Image data size mismatch: expected " + (width * height * nbands) + ", got " + values.length);
                    return;
                }

                // Table of min-max per band. These should come from the MRF XML
                let minMax = [];
                minMax.push({min: 6131, max: 65535}); // Band 0
                minMax.push({min: 6812, max: 35999}); // Band 1
                minMax.push({min: 6427, max: 20046}); // Band 2
                minMax.push({min: 5566, max: 20382}); // Band 3
                minMax.push({min: 4608, max: 32502}); // Band 4
                minMax.push({min: 4649, max: 65535}); // Band 5
                minMax.push({min: 4257, max: 65535}); // Band 6
                minMax.push({min: 4372, max: 13262}); // Band 7
                
                // This needs to convert the values to 8 bit and draw them
                let ctx = tile.getContext('2d');
                let imageData = ctx.createImageData(width, height);
                rband = this.selection[0];
                gband = this.selection[1];
                bband = this.selection[2];
                for (let i = 0; i < width * height; i++) {
                    let r = values[i * nbands + rband];
                    let g = values[i * nbands + gband];
                    let b = values[i * nbands + bband];
                    imageData.data[i * 4 + 3] = (r === 0 && g === 0 && b === 0) ? 0 : 255; // Alpha
                    r = 0xff & (512 * (r - minMax[rband].min) / (minMax[rband].max - minMax[rband].min));
                    g = 0xff & (512 * (g - minMax[gband].min) / (minMax[gband].max - minMax[gband].min));
                    b = 0xff & (512 * (b - minMax[bband].min) / (minMax[bband].max - minMax[bband].min));
                    imageData.data[i * 4] = r;
                    imageData.data[i * 4 + 1] = g;
                    imageData.data[i * 4 + 2] = b;
                    // Set alpha to 0 when all bands are zero
                }

                ctx.putImageData(imageData, 0, 0);
            }
        })
    </script>

    <style>
      body {
        margin:0;
        padding:0;
      }

      #map {
        position: absolute;
        top:0;
        bottom:0;
        right:0;left:0;
      }

      #info-pane {
        position: absolute;
        top: 10px;
        right: 10px;
        min-width: 200px;
        z-index: 500;
        padding: 1em;
        background: white;
      }

      #picker {
        position: relative;
        top: 10px;
        left: 10px;
        z-index: 500;
        padding: 1em;
        background: white;
      }

      .noUi-connect {
        background: #ccc;
      }
    </style>
  </head>

  <body>
    <div id="map"></div>
        <div id="info-pane">
        <h3>QB3 prototype</h3>
        <div id="picker">
            <select id="band-picker">
                <option value="4,3,2">Color</option>
                <option value="7,6,4">Short Wave IR</option>
                <option value="5,4,3">Color IR</option>
                <option value="6,5,2">Agriculture</option>
                <option value="4,3,1">Bathymetric</option>
                <option value="7,6,2">Geology</option>
            </select>
        </div>
    </div>

    <script>
        let southWest = L.latLng(-90, -179);
        let northEast = L.latLng(90, 179);
        let bounds = L.latLngBounds(southWest, northEast);

        // Create the map
        var map = L.map('map', {
            noWrap: true,
            center: [0, 0],
            zoom: 2,
            zoomControl: true,
            maxZoom: 5,
            // maxBounds: bounds,
            attributionControl: true
        });
    
      
        let QB3L = new QB3Layer({
            attribution: 'QB3 prototype'
        });
        QB3L.selection = [4,3,2]; // Red, Green, Blue bands

        // Read the band selection from the picker
        document.getElementById('band-picker').addEventListener('change', function() {
            let bands = this.value.split(',').map(Number);
            if (bands.length !== 3) {
                console.error("Please select exactly three bands.");
                return;
            }
            // Adjust the bands to be zero-indexed
            bands = bands.map(band => band - 1);
            QB3L.selection = bands;
            // Redraw the tiles in the layer

            // Time this loop
            console.time("Redraw Tiles");
            for (var key in QB3L._tiles) {
                var tile = QB3L._tiles[key].el;
                if (!tile || !tile.data || tile.data.length == 0) continue;
                QB3L.draw(tile);
            }
            console.timeEnd("Redraw Tiles");
        });
    
    </script>
  </body>
  </html>